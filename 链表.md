@[TOC](链表)

## 一. 典型例题

### 1.删除链表中值为val的节点

<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">https://leetcode-cn.com/problems/remove-linked-list-elements/</a>

#### 解法1：递归

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeElements(struct ListNode* head, int val){
    if(head == NULL)
        return head;
    
    head->next = removeElements(head->next, val);
    return head->val == val ? head->next : head;
}
```

#### 解法2：迭代

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

//迭代
struct ListNode* removeElements(struct ListNode* head, int val){
    if(head == NULL)
        return head;
    
    //创建哑节点，因为头节点的值也可能等于val
    struct ListNode* dummyHead = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummyHead->val = -111;  //哑节点的值不在节点数目范围内
    dummyHead->next = head;
    struct ListNode* curNode = dummyHead;

    while(curNode->next)
    {
        //当前节点的下一个节点的值等于val
        //当前节点的next节点跳转到下下一个节点
        if(curNode->next->val == val)
        {
            curNode->next = curNode->next->next;
        }
        //节点的值不等于val，更新到下一个节点
        else
        {
            curNode = curNode->next;
        }
    }

    return dummyHead->next;
}
```

#### 解法3：双指针

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* removeElements(struct ListNode* head, int val){
    if(head == NULL)
        return head;
    
    struct ListNode* prev = NULL;   //前驱节点
    struct ListNode* curNode = head;

    while(curNode)
    {
        if(curNode->val == val)
        {
            //没有前驱节点，更新头节点
            if(prev == NULL)
                head = curNode->next;
            else
                prev->next = curNode->next;
        }
        else
        {
            prev = curNode;
        }

        curNode = curNode->next;
    }

    return head;
}
```

#### 解法4：加一个头节点

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeElements(struct ListNode* head, int val){
    if(head == NULL)
        return head;
    
    //定义一个新的头节点方便操作
    struct ListNode* newHead = (struct ListNode*)malloc(sizeof(struct ListNode));
    newHead->val = -111;
    newHead->next = head;

    struct ListNode* prev = newHead;
    struct ListNode* curNode = head;
    while(curNode != NULL)
    {
        if(curNode->val != val)
        {
            prev->next = curNode;
            prev = curNode;
        }

        curNode = curNode->next;
    }   
    prev->next = NULL;  //断开无关节点的连接

    head = newHead->next;
    free(newHead);

    return head;
}
```



### 2.反转链表

<a href="https://leetcode-cn.com/problems/reverse-linked-list/submissions/">https://leetcode-cn.com/problems/reverse-linked-list/submissions/</a>

解法1：非递归的双指针

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

//非递归:双指针
struct ListNode* reverseList(struct ListNode* head){
    if(head == NULL || head->next == NULL)
        return head;
    
    struct ListNode* prevNode = NULL;
    struct ListNode* curNode = head;
    while(curNode)
    {
        struct ListNode* nextNode = curNode->next;
        curNode->next = prevNode;
        prevNode = curNode;
        curNode = nextNode;
    }

    return prevNode;
}
```

解法2：递归

```c
struct ListNode* reverseList(struct ListNode* head) {
    //head->next == NULL 是重要的递归结束条件
    if (head == NULL || head->next == NULL) {
        return head;
    }

    //递归获取到后面节点反转后的头节点
    struct ListNode* newHead = reverseList(head->next);
    //要想反转链表就要让当前节点的下一个节点指向当前节点
    //head->next表示当前节点的下一个节点
    //head->next->next表示下一个节点的下一个节点
    head->next->next = head;		//秀儿！！！！！！！！
    //让尾节点指向空
    head->next = NULL;
    return newHead;
}
```

### 3.链表的中间节点

<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/submissions/">https://leetcode-cn.com/problems/middle-of-the-linked-list/submissions/</a>

快慢指针法：

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

//快慢指针法
struct ListNode* middleNode(struct ListNode* head){
    if(head == NULL || head->next == NULL)
        return head;
    
    struct ListNode* slow = head;
    struct ListNode* fast = head;

    //这个题目最难的是循环条件的推导
    while(fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
    }

    return slow;
}
```

### 4.链表的倒数第k个节点

<a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&&tqId=11167&rp=2&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&&tqId=11167&rp=2&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking</a>

```c
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

/**
 * 
 * @param pListHead ListNode类 
 * @param k int整型 
 * @return ListNode类
 */

int getListLen(struct ListNode* node)
{
    if(node == NULL)
        return 0;
    int len = 0;
    struct ListNode* p = node;
    while(p)
    {
        ++len;
        p = p->next;
    }
    return len;
}

//快慢指针法
struct ListNode* FindKthToTail(struct ListNode* pListHead, int k ) {
    // write code here
    if(pListHead == NULL || k <= 0)
        return NULL;
   
    struct ListNode* p = pListHead;
    int len = getListLen(p);
    
    if(k > len)
        return NULL;
    struct ListNode* slow = pListHead;
    struct ListNode* faster = pListHead;
    
    while(k--)
        faster = faster->next;
    
    while(faster && slow)
    {
        faster = faster->next;
        slow = slow->next;
    }
    
    return slow;
}
```

### 5.合并两个有序链表

<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/">https://leetcode-cn.com/problems/merge-two-sorted-lists/description/</a>

#### 递归版

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

//递归
struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){
    if(l1 == NULL)
        return l2;
    if(l2 == NULL)
        return l1;
    
    struct ListNode* newHead = NULL;
    if(l1->val < l2->val)
    {
        newHead = l1;
        l1 = l1->next;
    }
    else
    {
        newHead = l2;
        l2 = l2->next;
    }

    newHead->next = mergeTwoLists(l1, l2);

    return newHead;
}
```

#### 非递归/迭代法

```c
/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; *///迭代/非递归struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){    if(l1 == NULL)        return l2;    if(l2 == NULL)        return l1;        struct ListNode* newHead = NULL;    if(l1->val < l2->val)    {        newHead = l1;        l1 = l1->next;    }    else    {        newHead = l2;        l2 = l2->next;    }    struct ListNode* prev = newHead;    while(l1 && l2)    {        if(l1->val < l2->val)        {            prev->next = l1;            prev = l1;            l1 = l1->next;        }        else        {            prev->next = l2;            prev = l2;            l2 = l2->next;        }    }    if(l1)        prev->next = l1;    if(l2)        prev->next = l2;    return newHead;}
```

### 6.链表切割

<a href="https://www.nowcoder.com/practice/0e27e0b064de4eacac178676ef9c9d70?tpId=8&&tqId=11004&rp=2&ru=/activity/oj&qru=/ta/cracking-the-coding-interview/question-ranking">Link</a>

将大问题分解为小问题，将小问题的解合并为原问题的解---------------分治法

也可是说是四指针法

```c
/*struct ListNode {    int val;    struct ListNode *next;    ListNode(int x) : val(x), next(NULL) {}};*///将链表分为两部分，一部分小于目标值，另一部分大于目标值//再将链表合并class Partition {public:    ListNode* partition(ListNode* pHead, int x) {        // write code here        if(pHead == NULL || pHead->next == NULL)            return pHead;               //小于目标值的链表的头尾节点        ListNode *lessHead = nullptr, *lessTail = nullptr;        //大于目标值的链表的头尾节点        ListNode *greaterHead = nullptr, *greaterTail = nullptr;        ListNode* curNode = pHead;                while(curNode)        {            //将小于目标值的链表节点串起来            if(curNode->val < x)            {                if(lessHead == nullptr)                {                    lessHead = curNode;                    lessTail = curNode;                }                else                {                    lessTail->next = curNode;                    lessTail = curNode;                }            }            //将大于目标值的节点连接起来            else            {                if(greaterHead == NULL)                {                    greaterHead = curNode;                    greaterTail = curNode;                }                else                {                    greaterTail->next = curNode;                    greaterTail = curNode;                }            }                        curNode = curNode->next;        }                //链表合并        if(lessTail)            lessTail->next = greaterHead;        else            lessHead = greaterHead;        if(greaterTail)            greaterTail->next = nullptr;                return lessHead;    }};
```

### 7.链表的回文结构

<a href="https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&&tqId=29370&rp=1&ru=/activity/oj&qru=/ta/2016test/question-ranking">https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&&tqId=29370&rp=1&ru=/activity/oj&qru=/ta/2016test/question-ranking</a>

#### 解法1：借助栈辅助

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};*/

//借助栈辅助
class PalindromeList {
public:
    bool chkPalindrome(ListNode* A) {
        // write code here
        if(A == nullptr || A->next == nullptr)
            return true;
        
        ListNode* node = A;
        stack<ListNode*> st;
        while(node)
        {
            st.push(node);
            node = node->next;
        }
        
        int sz_half = st.size() / 2;
        ListNode* curNode = A;

        while(sz_half--)
        {
            ListNode* top = st.top();
  
            if(top->val == curNode->val)
            {
                st.pop();
                curNode = curNode->next;
            }
            else
                return false;
        }
        
        return true;
    }
};
```

#### 解法2：反转链表后半部分+双指针

下面的两道题解对于中间节点的处理方式有所不同，但大致思路是一样的

第一种：

```cpp
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};*/

//反转链表后半部分+双指针
class PalindromeList {
public:
    bool chkPalindrome(ListNode* A) {
        // write code here
        if(A == nullptr || A->next == nullptr)
            return true;
       
        ListNode* middle = A;
        ListNode* faster = A;
        //走到链表的中间节点
        while(faster && faster->next)
        {
            faster = faster->next->next;
            middle = middle->next;
        }
        
        //反转后半部分链表
        ListNode* prev = nullptr;
        while(middle)
        {
            ListNode* nextNode = middle->next;
            middle->next = prev;
            prev = middle;
            middle = nextNode;
        }
        
        ListNode* frontNode = A;    //前半部分链表节点
        //比较前半部分链表和后半部分链表的值
        while(frontNode && prev)
        {
            if(frontNode->val != prev->val)
            {
               return false;
            }
            frontNode = frontNode->next;
            prev = prev->next;
        }
        
        //这里直接返回看起来好像不太严谨
        //但是实际的情况是合理的
        //根据节点个数位是奇数还是偶数，链表是否回文，
        //可以分为四种情况，但这四种情况都能处理
        return true;
    }
};
```

第二种：

```c++
//这道题我知道反转链表后再比较的思路，但是我不知道如何让处理奇数个元素的中间节点，最后发现可以忽略中间节点，/** * struct ListNode { *	int val; *	struct ListNode *next; * }; */class Solution {public:    /**     *      * @param head ListNode类 the head     * @return bool布尔型     */    bool isPail(ListNode* head) {        // write code here        if(head == nullptr || head->next == nullptr)        {            return head;        }                //找到链表的中间节点        ListNode* slow = head;	        ListNode* fast = head;	        while(fast != nullptr && fast->next != nullptr)        {            fast = fast->next->next;            slow = slow->next;        }        //fast不为空，说明链表节点的个数是奇数个        //为了反转后半部分链表，奇数个节点比较不需要中间节点        //让本来指向中间节点的指针指向中间节点的下一个位置        if(fast != nullptr)        {            slow = slow->next;        }                //反转后半部分链表        slow = Reverse(slow);        /////////////////test/////////////////////////        ListNode* node = slow;        while(node != nullptr)        {            cout << node->val << "--->";            node = node->next;        }        cout << endl;        //////////////////////////////////////////        fast = head;        //比较两个链表的元素        //为什么循环条件是这个，因为前半部分链表和后半部分链表之间没有断开        //两个链表需要比较的元素个数以后半部分链表为准        while(slow != nullptr)        {            if(fast->val != slow->val)            {                return false;            }            fast = fast->next;            slow = slow->next;        }        return true;    }    private:    ListNode* Reverse(ListNode* head)    {        if(head == nullptr || head->next == nullptr)        {            return head;        }                ListNode* prev = nullptr;        ListNode* nextNode = nullptr;        ListNode* curNode = head;        while(curNode != nullptr)        {            nextNode = curNode->next;            //反转链表因为太嚣张，不小心搞错了            curNode->next = prev;            prev = curNode;            curNode = nextNode;        }        return prev;    }};
```

### 8.找两个链表的第一个公共节点

<a href="https://www.nowcoder.com/profile/910187493/codeBookDetail?submissionId=121073599">Link</a>

#### 解法1：让长度长的链表先走

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
//方法1：让长的链表先走gap步

int getListLen(struct ListNode* node)
{
    if(node == NULL)
        return 0;

    int len = 0;
    while(node)
    {
        ++len;
        node = node->next;
    }

    return len;
}

struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    if(headA == NULL || headB == NULL)
        return NULL;
    
    int lenA = getListLen(headA);
    int lenB = getListLen(headB);
    int gap = lenA - lenB;
    struct ListNode* nodeA = headA;
    struct ListNode* nodeB = headB;

    if(gap > 0)
    {
        while(gap--)
        {
            nodeA = nodeA->next;
        }
    }
    else
    {
        gap = -gap;
        while(gap--)
        {
            nodeB = nodeB->next;
        }
    }

    while(nodeA && nodeB)
    {
        if(nodeA == nodeB)
            return nodeA;
        nodeA = nodeA->next;
        nodeB = nodeB->next;
    }
    return NULL;
}
```

#### 解法2：通过模拟让两个链表长度相等

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

//通过模拟两个链表长度相等来判断是否存在相交节点
/*
	链表1： 1 2 3 5 6
	链表2： 4 5 6
	虚拟后:
	链表1:  1 2 3 5 6 4 5 6 
	链表2:  4 5 6 1 2 3 5 6
*/
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    if(headA == NULL || headB == NULL)
        return NULL;
    
    struct ListNode* nodeA = headA;
    struct ListNode* nodeB = headB;

    while(nodeA != nodeB)
    {
        //当链表走到尾节点时，下一步走到另一个链表的头节点
        nodeA = nodeA ? nodeA->next : headB;
        nodeB = nodeB ? nodeB->next : headA; 
    }

    //当没有相交节点时，两个指针都走到了表尾后面的NULL
    return nodeA;
}
```

### 9.判断链表是否有环

<a href="https://leetcode-cn.com/problems/linked-list-cycle/submissions/">https://leetcode-cn.com/problems/linked-list-cycle/submissions/</a>

快慢指针法（龟兔赛跑算法)

为什么一个走两步，一个走一步，它们会相遇？

```c
/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; *///快慢指针法//如果是环形链表则两者肯定能相遇bool hasCycle(struct ListNode *head) {    if(head == NULL || head->next == NULL)        return false;        struct ListNode* slow = head;    struct ListNode* fast = head;        //快指针走得快，链表没有环，那么快指针会先走到链表的尾部    //如果链表中有环，快慢指针一定会相遇    while(fast && fast->next)    {        slow = slow->next;        fast = fast->next->next;        if(fast == slow)            return true;    }    return false;}
```

### 10.环形链表的起点

<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/description/">https://leetcode-cn.com/problems/linked-list-cycle-ii/description/</a>

```c
/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */struct ListNode *detectCycle(struct ListNode *head) {    if(head == NULL || head->next == NULL)        return NULL;    //先找到相遇点    struct ListNode* fast = head;    struct ListNode* slow = head;    bool isMeet = false;    //是否相遇     while(fast && fast->next)    {        fast = fast->next->next;        slow = slow->next;        if(fast == slow)        {            isMeet = true;            break;        }    }    //没有相遇    if(!isMeet)        return NULL;    //从起点和相遇点同时出发，每次走一步，相遇处就是起点    struct ListNode* curNode = head;    struct ListNode* meetNode = slow;    while(curNode && meetNode)    {        //判断必须放在前面，因为可能起点就是相遇点        if(curNode == meetNode)            break;        curNode = curNode->next;        meetNode = meetNode->next;    }    return curNode;}
```

### 11.复制带随机指针的链表

<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">Link</a>

```c
/** * Definition for a Node. * struct Node { *     int val; *     struct Node *next; *     struct Node *random; * }; *//*    思路是：        拷贝节点的值+next；        拷贝节点的random；        拆链*/struct Node* copyRandomList(struct Node* head) {	if(head == NULL)        return head;        //复制每个节点的值和next指向,形成一个新的链表    struct Node* curNode = head;    while(curNode)    {        struct Node* nextNode = curNode->next;      //保存下一个节点的指针        struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));   //创建新节点        newNode->val = curNode->val;    //拷贝之前节点的值        //链接新节点，更新指向        newNode->next = nextNode;        curNode->next = newNode;        curNode = nextNode;    }    //复制random指向    curNode = head;    struct Node* cloneNode = NULL;  //新拷贝的节点    while(curNode)    {        cloneNode = curNode->next;        if(curNode->random)            cloneNode->random = curNode->random->next;        else            cloneNode->random = NULL;        curNode = cloneNode->next;  //这个细节我之前没注意，所以浪费了时间    }    curNode = head;    struct Node* newHead = curNode->next;    //拆分链表    while(curNode)    {        cloneNode = curNode->next;        curNode->next = cloneNode->next;        curNode = curNode->next;        if(curNode)            cloneNode->next = curNode->next;        else            cloneNode->next = NULL;    }    return newHead;}
```

### 12.对链表进行插入排序

<a href="https://leetcode-cn.com/problems/insertion-sort-list/">https://leetcode-cn.com/problems/insertion-sort-list/</a>

```c
/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */struct ListNode* insertionSortList(struct ListNode* head){    if(head == NULL || head->next == NULL)        return head;        struct ListNode* dummyHead = (struct ListNode*)malloc(sizeof(struct ListNode));    dummyHead->val = -111;    dummyHead->next = head;    //从第二个节点进行插入排序    //这种设置最后一个有序节点的做法很优秀    struct ListNode* lastSorted = head;    struct ListNode* curNode = head->next;      while(curNode)    {        struct ListNode* nextNode = curNode->next;        //新插入节点的值大于最后一个有序节点的值        //将其插入有序链表        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        //在这里我因为心太急也就是粗心，把判断条件写成了        //curNode->val >= lastSorted        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        if(curNode->val >= lastSorted->val)        {            lastSorted->next = curNode;            lastSorted = lastSorted->next;        }        //新插入节点的位置在链表中，需要进行查找        else        {            struct ListNode* prevNode = dummyHead;            //从前往后找第一个大于新插入节点值的节点             //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!            //在这里我因为心太急也就是粗心，把判断条件写成了            //prevNode->next->val <= curNode            //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!            //这种做法只需要使用一个指针，这种代码风格是我想要的            while(prevNode->next->val <= curNode->val)            {                prevNode = prevNode->next;            }            curNode->next = prevNode->next;            prevNode->next = curNode;        }        curNode = nextNode;    }    //让有序链表的最后一个元素指向NULL    lastSorted->next = NULL;    head = dummyHead->next;    free(dummyHead);    return head;}
```

### 13.删除链表中重复的节点

<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/

</a>

传统思路

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

struct ListNode* deleteDuplicates(struct ListNode* head){
    if(head == NULL || head->next == NULL)
        return head;

    struct ListNode* newHead = (struct ListNode*)malloc(sizeof(struct ListNode));
    newHead->val = -1;  //不在链表元素节点的范围内
    newHead->next = head;
    struct ListNode* curNode = head;
    struct ListNode* prevNode = newHead;    //前一个节点

    while(curNode)
    {
        //遇见相邻元素不相等的情况，向后更新
        while(curNode->next && curNode->val != curNode->next->val)
        {
            prevNode->next = curNode;
            prevNode = curNode;
            curNode = curNode->next;
        }
		//遇见相邻元素相等的情况，向后更新当前节点
        while(curNode->next && curNode->val == curNode->next->val)
        {
            curNode = curNode->next;
        }
        
        //前一个非重复节点的下一个位置指向重复节点的下一个位置
        if(prevNode->next != curNode)
        {
            prevNode->next = curNode->next;
        }
        curNode = curNode->next;
    }

    head = newHead->next;
    free(newHead);

    return head;
}
```

一种更加简洁的做法：

```c
/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */struct ListNode* deleteDuplicates(struct ListNode* head){        if(head == NULL || head->next == NULL)            return head;        struct ListNode* newHead = (struct ListNode*)malloc(sizeof(struct ListNode));        newHead->val = -1;  //不在标准范围内        newHead->next = head;        struct ListNode* prev = newHead;        struct ListNode* curNode = head;        while(curNode != NULL)        {            //p->val == p->next->val 的隐含条件是p->next != NULL            //curNode->next == NULL说明到达了尾节点,这个时候就要结束了，            //让尾节点成为有序链表的最有一个有序节点            if(curNode->next == NULL || curNode->val != curNode->next->val)            {                prev->next = curNode;                prev = curNode;            }            //跳过重复项，到达该组重复数字的最后一个位置            while(curNode->next != NULL && curNode->val == curNode->next->val)            {                curNode = curNode->next;            }            /*                走到这里有两种情况：                1):  curNode现在是一组重复节点的最后一个，                    让curNode走到重复节点的下一个位置                2): curNode的下一个节点和它的值不相等，让curNode走到下一个位置            */            curNode = curNode->next;        }        //让尾节点的下一个位置指向NULL        prev->next = NULL;        return newHead->next;}
```

### 14.单链表的排序

<a href="https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=202&&tqId=38846&rp=1&ru=/activity/oj&qru=/ta/code-written-high/question-ranking">单链表排序</a>

#### 方法1：归并排序

```c++
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

//先将整个链表拆分到只有一个节点
//进行归并排序

class Solution {
public:
    /**
     * 
     * @param head ListNode类 the head node
     * @return ListNode类
     */
    ListNode* sortInList(ListNode* head) {
        // write code here
        if(head == nullptr || head->next == nullptr)
        {
            return head;
        }
        
        return mergeSort(head);
    }

private:
    //归并排序
    ListNode* mergeSort(ListNode* head)
    {
        if(head->next == nullptr)
        {
            return head;
        }
        
        ListNode* fast = head;
        ListNode* slow = head;
        
        /*
            找中间节点让我困惑了一段时间，
            在一个链表只有两个元素的情况下,
            fast = fast->next->next会陷入死循环
            在循环体内加入一个判断条件后就解决了这个问题
        */
        //找到中间节点
        while(fast && fast->next)
        {
            fast = fast->next;
            if(fast->next == nullptr)
            {
                break;
            }
            slow = slow->next;
        }
        
        //根据中间节点，将链表划分为两部分
        ListNode* head1 = head;
        ListNode* head2 = slow->next;
        slow->next = nullptr;        //将两个链表断开连接
        
        head1 = mergeSort(head1);
        head2 = mergeSort(head2);
        
        return Merge(head1, head2);
    }

    //有序链表的合并
    ListNode* Merge(ListNode* head1, ListNode* head2)
    {
        if(head1 == nullptr && head2 == nullptr)
        {
            return nullptr;
        }
        if(head1 == nullptr)
        {
            return head2;
        }
        if(head2 == nullptr)
        {
            return head1;
        }
        
        ListNode* newHead = nullptr;
        ListNode* node1 = head1;
        ListNode* node2 = head2;
        if(node1->val < node2->val)
        {
            newHead = node1;
            node1 = node1->next;
        }
        else
        {
            newHead = node2;
            node2 = node2->next;
        }
        ListNode* prev = newHead;
        
        while(node1 && node2)
        {
            if(node1->val < node2->val)
            {
                prev->next = node1;
                prev = node1;
                node1 = node1->next;
            }
            else
            {
                prev->next = node2;
                prev = node2;
                node2 = node2->next;
            }
        }
        while(node1)
        {
            prev->next = node1;
            prev = node1;
            node1 = node1->next;
        }
        while(node2)
        {
            prev->next = node2;
            prev = node2;
            node2 = node2->next;
        }
        
        prev->next = nullptr;
        return newHead;
    }
};
```

#### 方法2：借助辅助空间

```c++
/** * struct ListNode { *	int val; *	struct ListNode *next; * }; */class Solution {public:    /**     *      * @param head ListNode类 the head node     * @return ListNode类     */    ListNode* sortInList(ListNode* head) {        // write code here        if(!head || !head->next)        {            return head;        }                vector<int> tmp;        ListNode* curNode = head;        while(curNode)        {            tmp.push_back(curNode->val);            curNode = curNode->next;        }                sort(tmp.begin(), tmp.end());        curNode = head;        int idx = 0;        while(curNode)        {            curNode->val = tmp[idx++];            curNode = curNode->next;        }                return head;    }};
```

### 15.反转链表部分区间

<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/submissions/">Link</a>

#### 方法1：借助辅助空间

```cpp
/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public:    ListNode* reverseBetween(ListNode* head, int left, int right) {        vector<int> arr;        ListNode* curNode = head;        while(curNode)        {            arr.push_back(curNode->val);            curNode = curNode->next;        }        ReverseArr(arr, left - 1, right - 1);        curNode = head;        for(int i = 0; i < arr.size(); ++i)        {            curNode->val = arr[i];            curNode = curNode->next;        }        return head;    }private:    void ReverseArr(vector<int>& arr, int left, int right)    {        while(left < right)        {            int tmp = arr[left];            arr[left] = arr[right];            arr[right] = tmp;            left++;            right--;        }    }}
```

#### 方法2：穿针引线+两次遍历

```cpp
class Solution {private:    void reverseLinkedList(ListNode *head) {        // 也可以使用递归反转一个链表        ListNode *pre = nullptr;        ListNode *cur = head;        while (cur != nullptr) {            ListNode *next = cur->next;            cur->next = pre;            pre = cur;            cur = next;        }    }public:    ListNode *reverseBetween(ListNode *head, int left, int right) {        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论        ListNode *dummyNode = new ListNode(-501);	//取一个不在节点范围的值作为虚拟头节点的值        dummyNode->next = head;        ListNode *pre = dummyNode;        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点        // 建议写在 for 循环里，语义清晰        for (int i = 0; i < left - 1; i++) {            pre = pre->next;        }        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点        ListNode *rightNode = pre;        for (int i = 0; i < right - left + 1; i++) {            rightNode = rightNode->next;        }        // 第 3 步：切断出一个子链表（截取链表）        ListNode *leftNode = pre->next;        ListNode *curr = rightNode->next;        // 注意：切断链接        pre->next = nullptr;        rightNode->next = nullptr;        // 第 4 步：反转链表的子区间        reverseLinkedList(leftNode);        // 第 5 步：接回到原来的链表中        pre->next = rightNode;  //rightNode成为中间部分的头节点        leftNode->next = curr;  //left成为中间部分的尾节点        return dummyNode->next;    }};
```

缺点： 这种解法当[left,right]区间很大时，查找节点需要遍历一遍链表，反转需要再遍历一次链表

#### 方法3：穿针引线+一次遍历，一个神一般的反转链表

```cpp
class Solution {public:    ListNode *reverseBetween(ListNode *head, int left, int right) {        //设置一个虚拟头节点，减少复杂情况的讨论        ListNode *dummyNode = new ListNode(-1);        dummyNode->next = head;        ListNode *pre = dummyNode;        //走到第left-1个位置,也就是要反转部分的前一个位置        for (int i = 0; i < left - 1; i++) {            pre = pre->next;        }        ListNode *cur = pre->next;      //从要反转区间的第一个元素开始遍历        ListNode *next = nullptr;        for (int i = 0; i < right - left; i++) {            next = cur->next;             cur->next = next->next;		//更新到下一个位置            next->next = pre->next;		//将新的节点头插到头节点的前面            pre->next = next;			//更新头节点        }        return dummyNode->next;    }};
```

### 16.链表的奇偶重排

<a href="https://www.nowcoder.com/practice/02bf49ea45cd486daa031614f9bd6fc3?tpId=117&&tqId=37845&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking">link</a>

#### 四个指针解决

```cpp
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 *	ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    //双指针法
    ListNode* oddEvenList(ListNode* head) {
        // write code here
        ListNode* oddStart = nullptr;        //奇数序列的头部
        ListNode* oddEnd = nullptr;          //奇数序列的尾部
        ListNode* evenStart = nullptr;       //偶数序列的头部
        ListNode* evenEnd = nullptr;         //偶数序列的尾部
        
        int idx = 1;
        ListNode* curNode = head;
        ListNode* nextNode = nullptr;    //保存下一个节点
        while(curNode)
        {
            nextNode = curNode->next;
            //奇数
            if(idx % 2 == 1)
            {
                if(!oddEnd)
                {
                    oddEnd = curNode;
                    oddStart = curNode;
                }
                else
                {
                    //将新节点尾插到插入奇数序列的尾部
                    oddEnd->next = curNode;
                    oddEnd = curNode;
                }
            }
            //偶数
            else
            {
                if(!evenStart)
                {
                    evenStart = curNode;
                    evenEnd = curNode;
                }
                else
                {
                    //将新节点尾插到偶数序列的尾部
                    evenEnd->next = curNode;
                    evenEnd = curNode;
                }
            }
            idx++;
            curNode = nextNode;
        }
        
        //重新链接
        if(oddEnd)
        {
            oddEnd->next = evenStart;
        }
        if(evenEnd)
        {
            evenEnd->next = nullptr;
        }
        
        return oddStart;
    }
};
```

### 17.删除链表的倒数第n个节点

<a href="https://www.nowcoder.com/practice/f95dcdafbde44b22a6d741baf71653f6?tpId=117&&tqId=37750&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking">Link</a>

```cpp
/** * struct ListNode { *	int val; *	struct ListNode *next; * }; */  //找到倒数第n+1个节点，再改变指向,注意细节的把握class Solution {public:    /**     *      * @param head ListNode类      * @param n int整型      * @return ListNode类     */    ListNode* removeNthFromEnd(ListNode* head, int n) {        if(head == nullptr || n <= 0)        {            return nullptr;        }                ListNode* dummyHead = new ListNode(-1);        dummyHead->next = head;                ListNode* fast = dummyHead;        ListNode* slow = dummyHead;                //不管链表的长度是多少，快慢指针法可以根据长度自己做出调整，不需要我们做无关的操作        //比如说我刚才的n += 2,以为节点个数多了一个所以让n多加了1        ++n;        //让快指针先走n+1步        while(n--)        {            fast = fast->next;            if(fast == nullptr && n != 0)            {                return nullptr;            }        }                while(fast && slow)        {            fast = fast->next;            slow = slow->next;        }                if(slow->next)        {            slow->next = slow->next->next;        }        return dummyHead->next;    }};
```

### 18.两个链表生成相加链表

<a href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=188&&tqId=38610&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">Link</a>

#### 解法1：利用栈后进先出的特点

```cpp
/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    /**     *      * @param head1 ListNode类      * @param head2 ListNode类      * @return ListNode类     */    ListNode* addInList(ListNode* head1, ListNode* head2) {        // write code here        ListNode *node1 = head1, *node2 = head2;        stack<int> st1, st2;        while(node1 || node2)        {            if(node1)            {                st1.push(node1->val);                node1 = node1->next;            }            if(node2)            {                st2.push(node2->val);                node2 = node2->next;            }        }                ListNode* dummyHead = new ListNode(-1);        dummyHead->next = nullptr;                int carry = 0;    //进位        while(!st1.empty() || !st2.empty() || carry != 0)        {            int x = 0, y = 0, sum = 0;            if(!st1.empty())            {                x = st1.top();                st1.pop();            }            if(!st2.empty())            {                y = st2.top();                st2.pop();            }            sum = (x + y + carry) % 10;            carry = (x + y + carry) / 10;                        ListNode* newNode = new ListNode(sum);            ListNode* nextNode = dummyHead->next;            newNode->next = nextNode;            dummyHead->next = newNode;        }        return dummyHead->next;    }};
```

#### 解法2：反转链表，从头到尾累加

```cpp
/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; *///反转链表从头到尾相加//写完代码之后一定要仔细检查一遍class Solution {public:    /**     *      * @param head1 ListNode类      * @param head2 ListNode类      * @return ListNode类     */    ListNode* addInList(ListNode* head1, ListNode* head2) {        // write code here        ListNode* node1 = ReverseList(head1);        ListNode* node2 = ReverseList(head2);        ListNode* dummyHead = new ListNode(-1);    //虚拟头节点        dummyHead->next = nullptr;                int carry = 0;        while(node1 || node2 || carry != 0)        {            int x = 0, y = 0;            if(node1)            {                x = node1->val;            }            if(node2)            {                            y = node2->val;            }            int sum = (x + y + carry) % 10;            carry = (x + y + carry) / 10;            if(node1)            {                node1 = node1->next;            }            if(node2)            {                node2 = node2->next;            }            //将新节点头插到链表中            ListNode* newNode = new ListNode(sum);            ListNode* nextNode = dummyHead->next;            newNode->next = nextNode;            dummyHead->next = newNode;        }        return dummyHead->next;    }private:    //反转链表    ListNode* ReverseList(ListNode* head)    {        ListNode* prev = nullptr;        ListNode* nextNode = nullptr;        ListNode* curNode = head;        while(curNode)        {            nextNode = curNode->next;            curNode->next = prev;            prev = curNode;            curNode = nextNode;        }        return prev;    }};
```

### 19.链表中的节点每k个一组进行翻转

<a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=188&&tqId=38557&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">Link</a>

#### 解法1：递归

```cpp
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    ListNode* reverseKGroup(ListNode* head, int k) {
        // write code here
        if(!head)
        {
            return head;
        }
        ListNode* curNode = head;
        //走到下一轮要翻转节点的第一元素的位置
        int i = 0; 
        while(i < k)
        {
            curNode = curNode->next;
            i++;
            //这一轮的节点个数不足k个，返回头节点
            if(!curNode && i != k)
            {
                return head;
            }
        }
        
        ListNode* newHead = ReversePart(head, curNode);
        //此时的head就是这一轮k个节点的尾节点，让尾节点指向下一轮的头节点
        head->next = reverseKGroup(curNode, k);   
        return newHead;
    }
private:
        //反转区间[start,endNext-1]范围的节点
        ListNode* ReversePart(ListNode* start, ListNode* endNext)
        {
            ListNode* prev = nullptr; 
            ListNode* nextNode = nullptr; 
            while(start != endNext)
            {
                nextNode = start->next;
                start->next = prev;
                prev = start;
                start = nextNode;
            }
            return prev;
        }
};
```

#### 解法2：迭代

```cpp
/** * struct ListNode { *	int val; *	struct ListNode *next; * }; */class Solution {public:    /**     *      * @param head ListNode类      * @param k int整型      * @return ListNode类     */    ListNode* reverseKGroup(ListNode* head, int k) {        // write code here        if(head == nullptr || head->next == nullptr || k <= 1)        {            return head;        }                int len = getListLen(head);        if(k > len)        {            return head;        }                ListNode* dummyHead = new ListNode(-1);        dummyHead->next = head;        ListNode* prev = dummyHead;        ListNode* nextNode = nullptr;        ListNode* curNode = head;                //每次转换一组        for(int i = 0; i < len / k; ++i)        {            //翻转k个节点需要移动k-1步            for(int j = 0; j < k - 1; ++j)            {                nextNode = curNode->next;                curNode->next = nextNode->next;                //头插                 nextNode->next = prev->next;                prev->next = nextNode;            }            //每一轮结束后更新            prev = curNode;		//curNode指向尾元素            curNode = curNode->next;        }        return dummyHead->next;    }private:    //获取链表长度    int getListLen(ListNode* head)    {        if(head == nullptr)        {            return 0;        }                int len = 0;         ListNode* curNode = head;        while(curNode)        {            ++len;            curNode = curNode->next;        }        return len;    }};
```

### 20.划分链表

<a href="https://www.nowcoder.com/practice/1dc1036be38f45f19000e48abe00b12f?tpId=188&&tqId=38668&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">Link</a>

#### 双指针 * 2  = 四指针

```cpp
/** * struct ListNode { *	int val; *	struct ListNode *next; * }; */class Solution {public:    /**     *      * @param head ListNode类      * @param x int整型      * @return ListNode类     */    ListNode* partition(ListNode* head, int x) {        // write code here        //前半部分的头尾节点        ListNode *front_start = nullptr, *front_end = nullptr;        //后半部分的头尾节点        ListNode *rear_start = nullptr, *rear_end = nullptr;                ListNode* curNode = head;        //1.对节点进行尾插        while(curNode != nullptr)        {            //节点的值小于目标值，尾插到前半部分            if(curNode->val < x)            {                if(front_end == nullptr)                {                    front_start = curNode;                    front_end = curNode;                }                else                {                    front_end->next = curNode;                    front_end = curNode;                }            }            //节点的值大于等于目标值，尾插到后半部分            else            {                if(rear_start == nullptr)                {                    rear_start = curNode;                    rear_end = curNode;                }                else                {                    rear_end->next = curNode;                    rear_end = curNode;                }            }            curNode = curNode->next;        }                //2.将两个链表链接起来        //前半部分区间没有元素，更新头节点为后半部分区间的头节点        //!!!!!!!!!!!!!!  注意细节的判断 !!!!!!!!!!!!!!!!!!!!!!!!!!!!        if(front_start == nullptr)        {            front_start = rear_start;        }        if(front_end != nullptr)        {            front_end->next = rear_start;        }        if(rear_end != nullptr)        {            rear_end->next = nullptr;        }        return front_start;    }};
```

### 21.重排链表

<a href="https://www.nowcoder.com/practice/3d281dc0b3704347846a110bf561ef6b?tpId=188&&tqId=38604&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">Link</a>

#### 解法1：借助栈

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
//借助栈
class Solution {
public:
    void reorderList(ListNode *head) {
        if(!head)
        {
            return;
        }
        
        stack<ListNode*> st;
        ListNode* curNode = head;
        while(curNode)
        {
            st.push(curNode);
            curNode = curNode->next;
        }
        
        int listLen = st.size();
        curNode = head;
        ListNode* nextNode = nullptr;
        
        //1.将链表后一半的节点插入
        for(int i = 0; i < listLen / 2; ++i)
        {
            nextNode = curNode->next;
            ListNode* newNode = st.top();
            st.pop();
            
            //将节点插入
            curNode->next = newNode;
            newNode->next = nextNode;
            //更新
            curNode = nextNode;
        }
        
        //2.找到新链表的尾部，断开和无关节点的连接
        curNode = head;
        for(int i = 0; i < listLen - 1; ++i)
        {
            curNode = curNode->next;
        }
        curNode->next = nullptr;
    }
};
```

#### 解法2：反转链表+插入节点

这个题的思路我理解了，但是涉及到一些条件判断，导致这道题花费了我一些时间；

问题在于反转后的两个链表插入时，不管是奇数个节点的链表还是偶数个节点的链表最后都会陷入死循环，要找到这个死循环发生的位置，然后打破这个死循环

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

class Solution {
public:
    void reorderList(ListNode *head) {
        if(!head || !head->next)
        {
            return;
        }
        
        ListNode *slow = head, *fast = head;
        while(fast && fast->next)
        {
            fast = fast->next->next;
            slow = slow->next;
        }
        
        slow = Reverse(slow);
        fast = head;
        
        while(slow)
        {
            ListNode* slow_next = slow->next;
            ListNode* fast_next = fast->next;
            
            fast->next = slow;
            //偶数个节点的链表在最后会陷入死循环
            if(fast_next == slow)
            {
                break;
            }
            slow->next = fast_next;
            
            fast = fast_next;
            slow = slow_next;
            //奇数个节点的链表在最后会陷入死循环
            if(fast == slow)
            {
                break;
            }
        }
    }
private:
    ListNode* Reverse(ListNode* head)
    {
        ListNode* prev = nullptr;
        ListNode* nextNode = nullptr;
        ListNode* curNode = head;
        while(curNode)
        {
            nextNode = curNode->next;
            curNode->next = prev;
            prev = curNode;
            curNode = nextNode;
        }
        return prev;
    }
};
```

### 22.环形链表的约瑟夫环问题

<a href="https://www.nowcoder.com/practice/41c399fdb6004b31a6cbb047c641ed8a?tpId=188&&tqId=38612&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">Link</a>

```cpp
class Solution {
public:
    /**
     * 
     * @param n int整型 
     * @param m int整型 
     * @return int整型
     */
    struct ListNode
    {
        int val;
        ListNode* next;
        ListNode(int data)
            :val(data)
            ,next(nullptr)
        {}
    };
    
    int ysf(int n, int m) {
        // write code here
        ListNode* head = CreateCircleLinkList(n);
        ListNode* curNode = head;
        while(curNode != curNode->next)
        {
            //走到第m-1个人的位置
            for(int i = 0; i < m-2; ++i)
            {
                curNode = curNode->next;
            }
            //释放掉第m个节点
            ListNode* deleteNode = curNode->next;
            curNode->next = deleteNode->next;
            delete deleteNode;
            //更新到下一轮的起始位置
            curNode = curNode->next;
        }
        return curNode->val;
    }
private:
    //创建一个有n个节点的环形链表，链表的节点的值从1到n
    ListNode* CreateCircleLinkList(int n)
    {
        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next = nullptr;
        ListNode* tailNode = dummyHead;
        for(int i = 1; i <= n; ++i)
        {
            ListNode* newNode = new ListNode(i);
            tailNode->next = newNode;
            tailNode = newNode;
        }
        tailNode->next = dummyHead->next;
        delete dummyHead;
        return tailNode->next;
    }
};
```

### 23.合并k个已经排好序的链表

<a href="https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=188&&tqId=38611&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">Link</a>

#### 解法1：归并排序的变形

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

//归并排序的应用
class Solution {
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        if(lists.empty())
        {
            return nullptr;
        }
        int listSz = lists.size();
        int step = 1;
        while(step < listSz)
        {
            for(int i = 0; i < listSz; i += 2 * step)
            {
                int firstNodeIdx = i, secondNodeIdx = i + step;
                if(secondNodeIdx >= listSz)
                {
                    break;
                }
                lists[firstNodeIdx] = mergeTwoLists(lists[firstNodeIdx], lists[secondNodeIdx]);
            }
            step *= 2;
        }
        return lists[0];
    }

private:
    //合并两个有序链表
    ListNode* mergeTwoLists(ListNode* head1, ListNode* head2)
    {
        if(!head1 && !head2)
        {
            return nullptr;
        }
        if(!head1)
        {
            return head2;
        }
        if(!head2)
        {
            return head1;
        }
        
        ListNode* newHead = nullptr;
        ListNode* node1 = head1;
        ListNode* node2 = head2;
        if(node1->val < node2->val)
        {
            newHead = node1;
            node1 = node1->next;
        }
        else
        {
            newHead = node2;
            node2 = node2->next;
        }
        
        ListNode* prev = newHead;
        while(node1 && node2)
        {
            if(node1->val < node2->val)
            {
                prev->next = node1;
                prev = node1;
                node1 = node1->next;
            }
            else
            {
                prev->next = node2;
                prev = node2;
                node2 = node2->next;
            }
        }
        while(node1)
        {
            prev->next = node1;
            prev = node1;
            node1 = node1->next;
        }
        while(node2)
        {
            prev->next = node2;
            prev = node2;
            node2 = node2->next;
        }
        prev->next = nullptr;
        return newHead;
    }
};
```

#### 解法2：优先级队列辅助

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

//将元素放入堆中,我认为时间复杂度为O(N)

//小根堆的比较函数
struct Cmp
{
    bool operator()(ListNode* node, ListNode* node2)
    {
        return node->val > node2->val;
    }
};

class Solution {
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        priority_queue<ListNode*, vector<ListNode*>, Cmp> q;
        //将所有节点插入堆中
        for(int i = 0; i < lists.size(); ++i)
        {
            while(lists[i])
            {
                q.push(lists[i]);
                lists[i] = lists[i]->next;
            }
        }
        
        ListNode* newHead = new ListNode(1001);
        newHead->next = nullptr;
        ListNode* tailNode = newHead;
        while(!q.empty())
        {
            tailNode->next = q.top();
            tailNode = q.top();
            q.pop();
        }
        tailNode->next = nullptr;
        return newHead->next;
    }
};
```

## 二. 刷题心得

1.链表这种题型，就要舍得用指针；

2.为了避免复杂度问题的讨论，在头节点前面加一个哑节点总不会错；

3.找链表的中间节点，需要使用快慢指针法，但是根据条件判断的不同，中间节点的位置也会不同，

如: fast && fast->next ,对于有奇数个节点的链表找到的是最中间的节点，而对于偶数个节点找到的是最中间两个节点的后一个；

fast->next && fast->next->next,对于有奇数个节点的链表找到的是最中间的节点，而对于偶数个节点找到的是最中间两个节点的前一个；

4.判断链表是否有环，让一个指针每次走一步，一个指针每次走两步，这样就会相遇；
