@[TOC](基础算法题)

## 1.二维数组中的查找

<a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?">Link</a>

题目简介：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211210091050880.png" alt="image-20211210091050880" style="zoom:50%;" />

**考察点：二分查找**

**解题思路：**

​	从右上角开始搜索，比较当前位置的值和目标值，

​	如果当前元素的值等于目标值，查找结束；

​	如果当前元素的值大于目标值，根据数组中元素从左到右递增、从上到下递增的顺序，目标值只能出现在当前位置的左边，去左边查找；

​	如果当前元素的值小于目标值，根据数组的特点，目标值只能出现在当前位置的下方，去下方查找；

​	重复比较步骤，直到找到目标值或者当前位置越界。

**代码：**

```cpp
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        int rows = array.size();
        int cols = array[0].size();
        int curX = 0, curY = cols - 1;        
        //从右上角开始查找
        while(curX < rows && curY >= 0)
        {
            if(target == array[curX][curY])
            {
                return true;
            }
            //目标值大于当前位置的元素，去下一行查找
            else if(target > array[curX][curY])
            {
                ++curX;
            }
            //目标值小于当前位置的元素，去左边的一列进行查找
            else
            {
                --curY;
            }
        }
        
        return false;
    }
};
```

## 2.替换空格

<a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?">**Link</a>**

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211210091420420.png" alt="image-20211210091420420" style="zoom:80%;" />

**考察点：字符串处理**

**解题思路：**

1. 计算替换后的空间大小；

2. 从尾到头进行替换，将空格替换为%20,将非空格直接插入；

   ​	至于为什么要从后往前替换？这是因为从后往前替换不会覆盖元素

```cpp
class Solution {
public:
	void replaceSpace(char *str,int length) {
        if(!str)
        {
            return;
        }
        
        int numOfSpace = 0;
        //1.统计空格的个数
        for(int i = 0; i < length; ++i)
        {
            if(str[i] == ' ')
            {
                ++numOfSpace;
            }
        }
        
        //2.从后往前进行替换,包括字符串结尾的结束标志
        int newIdx = length + 2 * numOfSpace;
        int oldIdx = length;
        while(oldIdx >= 0)
        {
            if(str[oldIdx] == ' ')
            {
                str[newIdx--] = '0';
                str[newIdx--] = '2';
                str[newIdx--] = '%';
                --oldIdx;        //这里没有让oldIdx更新，所以会产生错误，细节细节!!!!!!!
            }
            else
            {
                str[newIdx--] = str[oldIdx--];
            }
        }
	}
};
```

## 3.从尾到头打印链表

<a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?">Link</a>

题目简介：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211210091710520.png" alt="image-20211210091710520" style="zoom:50%;" />

**考察点：栈的使用**

### 解法1：递归

解题思路：

​	先处理当前节点的后序节点，再将当前节点的值插入结果集

```cpp
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> res;
        printListFromTailToHeadHelper(head, res);
        return res;
    }
private:
    void printListFromTailToHeadHelper(ListNode* head, vector<int>& res)
    {
        if(!head)
        {
            return;
        }
        
        printListFromTailToHeadHelper(head->next, res);
        res.push_back(head->val);
    }
};
```

### 解法2：使用栈进行非递归

解题思路：

​	将链表中的节点从头到尾入栈，然后进行出栈操作直到栈为空，出栈时将元素的值插入结果集，根据后进先出的特点，从栈顶到栈底的顺序就是从尾到头的顺序

```cpp
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> res;
        stack<ListNode*> st;
        while(head)
        {
            st.push(head);
            head = head->next;
        }
        
        while(!st.empty())
        {
            res.push_back(st.top()->val);
            st.pop();
        }
        
        return res;
    }
};
```

## 4.二叉树重建

<a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211210092206108.png" alt="image-20211210092206108" style="zoom:50%;" />

**考察点：对二叉树前序遍历和中序遍历的理解**

### 解法1：手动划分左右子树区间

解题思路：

​	拿到前序序列的起始位置的值，也就是根节点的值，在中序序列中查找根节点的位置，根据找到的位置将中序序列划分为两部分，前半部分是左子树的中序遍历序列，后半部分是右子树的中序遍历序列。因为二叉树前序遍历序列的长度和中序遍历序列的长度相等，所以可以根据左子树中序遍历序列的长度计算出左子树前序遍历区间的结束位置，进而计算出右子树前序遍历区间的起始位置，至此，左右子树前序遍历序列和中序遍历序列的起始和结束位置确定，可以根据左右子树的前序区间和中序区间递归创建左右子树。

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        return reConstructBinaryTreeHelper(pre, 0, pre.size() - 1,
            vin, 0, vin.size() - 1);
    }
private:
    TreeNode* reConstructBinaryTreeHelper(const vector<int>& pre, int start_pre, int end_pre,
        const vector<int>& vin, int start_vin, int end_vin)
    {
        //当一个区间的左边没有元素时，会出现这种判断
        if(start_pre > end_pre || start_vin > end_vin)
        {
            return nullptr;
        }
        
        int rootVal = pre[start_pre];
        TreeNode* root = new TreeNode(rootVal);
        //1.在中序序列中找根节点的位置
        int mid = start_vin;
        while(mid <= end_vin)
        {
            if(vin[mid] == rootVal)
            {
                break;
            }
            ++mid;
        }
        
        //2.根据中序序列中根节点的位置分别构建二叉树的左右子树
        if(start_vin < mid)
        {
            //存在左子树
            root->left = reConstructBinaryTreeHelper(pre, start_pre + 1, start_pre + mid - start_vin, vin, start_vin, mid - 1);
        }
        else
        {
            //左子树为空
            root->left = nullptr;
        }
        if(mid < end_vin)
        {
            //存在右子树
            root->right = reConstructBinaryTreeHelper(pre, start_pre + mid - start_vin + 1, end_pre, vin, mid + 1, end_vin);
        }
        else
        {
            //右子树为空
            root->right = nullptr;
        }
        
        return root;
    }
};
```

### 解法2：使用引用代替手动计算区间

解题思路：

在中序序列中查找前序序列中当前元素出现的位置，将中序序列分为左右子树，递归创建左右子树

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        int preIdx = 0;
        return reConstructBinaryTreeHelper(pre, preIdx, vin, 0, vin.size() - 1);
    }
private:
    TreeNode* reConstructBinaryTreeHelper(const vector<int>& pre, int& preIdx,
        const vector<int>& vin, int start_vin, int end_vin)
    {
        //区间不合法，说明没有元素
        if(start_vin > end_vin)
        {
            return nullptr;
        }
        
        int rootVal = pre[preIdx];
        TreeNode* root = new TreeNode(rootVal);        //创建根节点
        int mid = start_vin;
        //在中序序列中找到根节点出现的位置
        while(mid <= end_vin)
        {
            if(vin[mid] == rootVal)
            {
                break;
            }
            ++mid;
        }
        
        if(start_vin < mid)
        {
            //根节点的左边至少有1个元素
            root->left = reConstructBinaryTreeHelper(pre, ++preIdx, vin, start_vin, mid - 1);
        }
        else
        {
            //根节点的左边没有元素
            root->left = nullptr;
        }
        if(mid < end_vin)
        {
            //根节点的右边至少有一个元素
            root->right = reConstructBinaryTreeHelper(pre, ++preIdx, vin, mid + 1, end_vin);
        }
        else
        {
            //根节点的右边没有元素
            root->right = nullptr;
        }
        
        return root;
    }
};
```

## 5.数组的旋转

<a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211211155433326.png" alt="image-20211211155433326" style="zoom:50%;" />

**考察点：二分查找**

**解题思路：**

原数组整体非递减排列，旋转之后数组分为前半部分和后半部分，两部分都呈非递减排列，但前半部分区间元素的值大于后半部分区间元素的值，而后半部分区间的起始位置就是目标位置。

使用两个指针维护一个区间，一个指针left之前区间的起始位置，一个指针right指向区间的结束位置，

比较区间中间位置的元素和起始位置的元素，

如果中间位置的元素大于等于起始位置的元素，说明当前区间的前半部分非递减排列，那么目标位置在后半部分，去后半部分查找；

如果中间位置的元素小于起始位置的元素，说明当前区间的前半部分先非递减排列，再突然下降，然后非递减排列，目标位置就在前半部分；

重复比较操作直到left的下一个位置就是right，此时两个区间相邻，left为前半部分区间的结束位置，right是后半部分区间的起始位置，查找结束，返回right位置对应的值

当然这道题中要考虑特殊情况，如果中间位置的值和区间起始位置的值、区间结束位置的值相等，则需要进行线性遍历，找到最小值

**代码：**

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        int preIdx = 0;
        return reConstructBinaryTreeHelper(pre, preIdx, vin, 0, vin.size() - 1);
    }
private:
    TreeNode* reConstructBinaryTreeHelper(const vector<int>& pre, int& preIdx,
        const vector<int>& vin, int start_vin, int end_vin)
    {
        if(start_vin > end_vin)
        {
            return nullptr;
        }
        
        int rootVal = pre[preIdx];
        TreeNode* root = new TreeNode(rootVal);        //创建根节点
        int mid = start_vin;
        //再中序序列中找到根节点出现的位置
        while(mid <= end_vin)
        {
            if(vin[mid] == rootVal)
            {
                break;
            }
            ++mid;
        }
        
        if(start_vin < mid)
        {
            //根节点的左边至少有1个元素
            root->left = reConstructBinaryTreeHelper(pre, ++preIdx, vin, start_vin, mid - 1);
        }
        else
        {
            //根节点的左边没有元素
            root->left = nullptr;
        }
        if(mid < end_vin)
        {
            //根节点的右边至少有一个元素
            root->right = reConstructBinaryTreeHelper(pre, ++preIdx, vin, mid + 1, end_vin);
        }
        else
        {
            //根节点的右边没有元素
            root->right = nullptr;
        }
        
        return root;
    }
};
```

## 6.斐波那契数列

<a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211211161237262.png" alt="image-20211211161237262" style="zoom:50%;" />

**考察点：动态规划**

### 解法1：递归

```cpp
class Solution {
public:
    int Fibonacci(int n) {
        if(n < 3)
        {
            return 1;
        }
        
        return Fibonacci(n - 1) + Fibonacci(n - 2);
    }
};
```

### 解法2：动态规划

解题思路：

斐波那契数列的特点是从第三项开始每一项的值等于前两项的值之和，可以根据子问题的解得到原问题的解，所以可以采用动态规划的思想，用空间换时间

```cpp
class Solution {
public:
    int Fibonacci(int n) {
        if(n < 3)
        {
            return 1;
        }
        
        vector<int> F(n + 1);        //状态：F[i]: 第i项斐波那契数列的值
        //为状态赋初值
        F[1] = 1;
        F[2] = 1;
        for(int i = 3; i <= n; ++i)
        {
            //状态转移方程
            F[i] = F[i - 1] + F[i - 2];
        }
        
        return F[n];
    }
};
```

### 解法3：动态规划的优化

解题思路：

每一项的值的计算只需要前两项元素的值，可以只保存前两项元素的值，空间复杂度就可以从O(N)变为O(1)

```cpp
class Solution {
public:
    int Fibonacci(int n) {
        if(n < 3)
        {
            return 1;
        }
        
        //prev_prev：当前项的前前项
        //prev：当前项的前一项
        //cur:当前项
        int prev_prev = 1, prev = 1, cur;
        for(int i = 3; i <= n; ++i)
        {
            //当前项的值等于前两项的值之和
            cur = prev_prev + prev;
            //更新
            prev_prev = prev;
            prev = cur;
        }
        
        return cur;
    }
};
```

## 7.青蛙跳台阶

<a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211211163055217.png" alt="image-20211211163055217" style="zoom:50%;" />

**考察点：动态规划**

解题思路：

对于1级台阶，青蛙只有一种跳法；

对于2级台阶，青蛙可以一级一级跳，也可以一次跳两级；

对于3级台阶，青蛙最后一次可以跳一步，也可以跳两步，跳一步问题就退化为2级台阶问题，跳两步就退化为了一级台阶问题

根据青蛙跳台阶的特点，可以发现每一项的值等于前两项的值之和，这正是一个斐波那契额数列问题

**代码:**

```cpp
class Solution {
public:
    int jumpFloor(int number) {
        if(number == 0 || number == 1)
        {
            return 1;
        }
        int prev_prev = 1, prev = 1, cur;
        for(int i = 2; i <= number; ++i)
        {
            cur = prev_prev + prev;
            prev_prev = prev;
            prev = cur;
        }
        
        return cur;
    }
};
```

## 8.矩形覆盖问题

<a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211211164030686.png" alt="image-20211211164030686" style="zoom:67%;" />

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211211164050822.png" alt="image-20211211164050822" style="zoom:67%;" />

**考察点：动态规划**

**解题思路：**

n=1,只有一种解法

n=2,可以横着放，也可以竖着放

n=3,可以选择最后一个矩形竖着放，也可以选择最后两个矩形横着放，摞起来，此时问题就退化为求前两项元素的和，这是一道斐波那契数列问题

**代码:**

```cpp
class Solution {
public:
    int rectCover(int number) {
        if(number == 0)
        {
            return 0;
        }
        if(number == 1)
        {
            return 1;
        }
        if(number == 2)
        {
            return 2;
        }
        
        //这道题的状态迁移方程理解还不是很到位
        int prev_prev = 1, prev = 2, cur;
        for(int i = 3; i <= number; ++i)
        {
            cur = prev_prev + prev;
            prev_prev = prev;
            prev = cur;
        }
        return cur;
    }
};
```

## 9.二进制中1的个数

<a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211211164723337.png" alt="image-20211211164723337" style="zoom:50%;" />

**考察点：位运算**

### 解法1

解题思路：

一个int型数据总计32位，遍历每一位，判断该位是否为1，需要遍历32次

```cpp
class Solution {
public:
     int  NumberOf1(int n) {
         int cnt = 0;
         for(int i = 0; i < 32; ++i)
         {
             if((1 << i) & n)
             {
                 ++cnt;
             }
         }
         
         return cnt;
     }
};
```

### 解法2

解题思路：

每次消除最右边的1，只需要循环二进制中1的个数次

```cpp
class Solution {
public:
     int  NumberOf1(int n) {
         int cnt = 0;
         while(n != 0)
         {
             ++cnt;
             n &= (n - 1);        //消除最右边的1
         }
         
         return cnt;
     }
};
```

## 10.调整数组顺序使奇数位于偶数前面

<a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211211165458836.png" alt="image-20211211165458836" style="zoom:50%;" />

**考察点：数组元素移动**

**解题思路：**

维护一个奇数区间，这个区间从0号下标开始，结束于idx-1；

从头到尾扫描数组，遇见偶数不做处理，遇见奇数将其前面的所有偶数向后移动一位

**代码：**

```cpp
class Solution {
public:
    void reOrderArray(vector<int> &array) {
        int nextOdd = 0;        //奇数区间末尾的下一个位置，也就是下一个奇数插入的位置
        for(int idx = 0; idx < array.size(); ++idx)
        {
            if(array[idx] % 2 == 1)
            {
                int data = array[idx];        //要插入的奇数
                //检查当前位置和奇数区间的末尾之间是否有偶数，有则将这个范围的偶数向后移动一位
                for(int idx2 = idx; idx2 > nextOdd; --idx2)
                {
                    array[idx2] = array[idx2 - 1];
                }
                array[nextOdd++] = data;
            }
        }
    }
};
```

## 11.输出单链表的倒数第k个节点

<a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211211170031230.png" alt="image-20211211170031230" style="zoom:50%;" />

**考察点：快慢指针、栈**

### 解法1：通过栈辅助

解题思路：将链表从头到尾入栈，让栈顶元素出栈k-1次，此时的栈顶元素就是倒数第k个节点

代码：

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindKthToTail(ListNode* head, unsigned int k) {
        if(!head || k <= 0)
        {
            return nullptr;
        }
        
        stack<ListNode*> st;
        while(head)
        {
            st.push(head);
            head = head->next;
        }
        if(k > st.size())
        {
            return nullptr;
        }
        
        --k;
        //让栈顶的k-1个元素出栈
        while(k--)
        {
            st.pop();
        }
        
        return st.top();
    }
};
```

### 解法2：快慢指针

解题思路：

定义两个指针都指向链表的头节点，一个是快指针，一个是慢指针，让快指针先走k步，再让快指针和慢指针同时向后，当快指针指向空节点时，慢指针指向倒数第k个节点

代码：

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        if(!pListHead)
        {
            return nullptr;
        }
        
        ListNode *fast = pListHead, *slow = pListHead;
        while(k--)
        {
            if(!fast)
            {
                return nullptr;
            }
            fast = fast->next;
        }
        
        while(fast)
        {
            fast = fast->next;
            slow = slow->next;
        }
        
        return slow;
    }
};
```

## 12.反转链表

<a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213142812468.png" alt="image-20211213142812468" style="zoom:50%;" />

**考察点：单链表性质**

### 解法1：迭代

解题思路：

定义前驱节点prev,初始化为nullptr,遍历链表，让当前节点的下一个位置指向前驱节点，同时更新前驱节点为当前节点，当链表遍历完毕之后，前驱节点就是反转链表的头部

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* head) {
        if(!head || !head->next)
        {
            return head;
        }
        
        ListNode* prev = nullptr;
        while(head)
        {
            ListNode* nextNode = head->next;
            head->next = prev;
            prev = head;
            head = nextNode;
        }
        
        return prev;
    }
};
```

### 解法2：递归

解题思路：

先反转链表当前头部节点后面的部分，让反转之后链表尾部的下一个位置指向当前当前节点，同时让当前节点的下一个位置指向空

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* head) {
        if(!head || !head->next)
        {
            return head;
        }
        
        ListNode* newHead = ReverseList(head->next);
        //head->next指向第二个节点，也就是反转部分链表的尾节点
        //让尾节点的下一个位置指向当前节点，a成功将反转后的链表和当前节点串联了起来
        head->next->next = head;
        //让当前节点的下一个位置指向空节点，保证链表的尾节点指向空
        head->next = nullptr;
        
        return newHead;
    }
};
```

### 解法3：头插

解题思路：

定义一个节点作为新链表的头节点，在遍历链表的过程中，将当前节点插入到新链表的头部，并且更新新链表的头节点，重复这一步直到链表遍历结束

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* head) {
        if(!head || !head->next)
        {
            return head;
        }
        
        ListNode* newHead = nullptr;   //反转后链表的头节点
        ListNode* curNode = head;      //当前节点
        while(curNode)
        {
            ListNode* nextNode = curNode->next;    //记录当前节点的下一个位置
            curNode->next = newHead;               //将当前节点头插到新链表中
            newHead = curNode;                     //更新新链表的头节点
            curNode = nextNode;
        }
        
        return newHead;
    }
};
```

## 13.有序链表的合并

<a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213145539033.png" alt="image-20211213145539033" style="zoom:50%;" />

### 解法1：迭代

**解题思路：**

比较两个链表的头节点，找到较小的节点作为新链表的头节点，依次比较两个链表的剩余节点，并将较小的节点尾插到新链表中

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* head1, ListNode* head2) {
        if(!head1)
        {
            return head2;
        }
        if(!head2)
        {
            return head1;
        }
        
        //1.确定头节点
        ListNode* newHead = nullptr;
        if(head1->val < head2->val)
        {
            newHead = head1;
            head1 = head1->next;
        }
        else
        {
            newHead = head2;
            head2 = head2->next;
        }
        ListNode* prev = newHead;
        
        //2.对链表中的节点两两比较，找到较小值，尾插到新链表中
        while(head1 && head2)
        {
            if(head1->val < head2->val)
            {
                prev->next = head1;
                prev = head1;
                head1 = head1->next;
            }
            else
            {
                prev->next = head2;
                prev = head2;
                head2 = head2->next;
            }
        }
        //处理剩余节点
        if(head1)
        {
            prev->next = head1;
        }
        if(head2)
        {
            prev->next = head2;
        }
        
        return newHead;
    }
};
```

### 解法2：递归

**解题思路：**

比较两个链表头节点值的大小，让小的节点作为当前的头节点，同时让指针向后移动，合并剩余的节点

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        if(!pHead1)
        {
            return pHead2;
        }
        if(!pHead2)
        {
            return pHead1;
        }
        
        ListNode* newHead = nullptr;
        if(pHead1->val < pHead2->val)
        {
            newHead = pHead1;
            pHead1 = pHead1->next;
        }
        else
        {
            newHead = pHead2;
            pHead2 = pHead2->next;
        }
        newHead->next = Merge(pHead1, pHead2);
        return newHead;
    }
};
```

## 14.二叉树的子结构

<a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213151806518.png" alt="image-20211213151806518" style="zoom:50%;" />

**考察点：递归**

**解题思路：**

​	判断一颗二叉树A是不是另一颗二叉树B的子树，有三种情况：

​		情况1：两颗二叉树的根节点值相等，而且B的左子树包含A的左子树，B的右子树包含A的右子树

​		情况2：两棵二叉树的根节点的值不相等，但是B的左子树包含A

​		情况3：两颗二叉树的根节点的值不相等，但是B的右子树包含A

​	这三种情况任何一种满足，都能说明A是B的子结构

```cpp
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        //题目规定：空树不是任何一棵树的子结构
        if(!pRoot2)
        {
            return false;
        }
        //空树不是非空树的父结构
        if(!pRoot1)
        {
            return false; 
        }
        
        return IsSameFromRoot(pRoot1, pRoot2)
            || HasSubtree(pRoot1->left, pRoot2)
            || HasSubtree(pRoot1->right, pRoot2);
    }
private:
        //判断从根节点开始是否匹配
        bool IsSameFromRoot(TreeNode* pRoot1, TreeNode* pRoot2)
        {
            //子树走到空节点处，说明匹配结束
            if(!pRoot2)
            {
                return true;
            }
            //父树走到了空节点处，但是子树不为空，说明了不匹配
            if(!pRoot1)
            {
                return false;
            }
            //根节点的值不相等，说明不匹配
            if(pRoot1->val != pRoot2->val)
            {
                return false;
            }
            //判断左右子树是否符合包含关系
            return IsSameFromRoot(pRoot1->left, pRoot2->left)
                && IsSameFromRoot(pRoot1->right, pRoot2->right);
        }
};
```

## 15.二叉树的镜像

<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213152956138.png" alt="image-20211213152956138" style="zoom:50%;" />

**考察点：递归**

**解题思路：将左右孩子交换，对左右孩子分别进行镜像调整**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(root == nullptr)
        {
            return root;
        }
        swap(root->left, root->right);
        mirrorTree(root->left);
        mirrorTree(root->right);
        return root;
    }
};
```

## 16.删除链表中的重复节点

<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/submissions/">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213154116032.png" alt="image-20211213154116032" style="zoom:50%;" />

**考察点：双指针**

### 解法1：遍历链表，找到重复区间的起始位置和结束位置，将重复区间从链表中断开

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head || !head->next)
        {
            return head;
        }

        //定义一个哑节点，避免复杂情况的讨论
        ListNode* dummyHead = new ListNode(101);
        dummyHead->next = head;
        ListNode *prev = dummyHead, *last = head;

        while(last)
        {
            //last走到重复区间的起始位置
            while(last->next && last->val != last->next->val)
            {
                prev->next = last;
                prev = prev->next;
                last = last->next;
            }
            //last走到重复区间的结束位置
            while(last->next && last->val == last->next->val)
            {
                last = last->next;
            }
            //将重复区间的元素从链表中删除
            if(prev->next != last)
            {
                prev->next = last->next;
            }    
            //更新last        
            last = last->next;
        }

        head = dummyHead->next;
        delete dummyHead;

        return head;
    }
};
```

### 解法2：优化

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head || !head->next)
        {
            return head;
        }

        //定义一个哑节点，避免复杂情况的讨论
        ListNode* dummyHead = new ListNode(101);
        dummyHead->next = head;
        ListNode *prev = dummyHead, *curNode = head;    //prev：前一个非重复元素

        while(curNode)
        {
            //如果当前节点走到了尾节点或者当前节点和它的下一个位置的节点的值不相等，更新prev
            if(!curNode->next || curNode->val != curNode->next->val)
            {
                prev->next = curNode;
                prev = prev->next;
            }
            //走到重复区间的尾部
            while(curNode->next && curNode->val == curNode->next->val)
            {
                curNode = curNode->next;
            }
            //更新curNode为当前重复区间的下一个位置
            curNode = curNode->next;
        }

        prev->next = nullptr;       //让尾节点的下一个指向空
        head = dummyHead->next;
        delete dummyHead;

        return head;
    }
};
```

## 17.最小栈

<a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213161753232.png" alt="image-20211213161753232" style="zoom:50%;" />

**考察点：栈的性质**

**解题思路：**

使用两个栈，一个栈存储入栈的数据，另一个栈存储当前栈中最小的元素，在入栈数据的时候更新最小栈，在出栈数据的时候也更新最小栈

### 解法1：让数据栈和最小栈元素个数相等

每次在入栈数据的时候，如果当前元素小于最小栈栈顶元素，将当前元素入栈到最小栈，否则将最小栈的栈顶元素重新入栈到最小栈中，保持数据栈和最小栈元素个数相同，出栈时数据栈和最小栈同时出栈

```cpp
class Solution {
private:
    stack<int> _data;
    stack<int> _min;
public:
    void push(int value) {
        _data.push(value);
        if(_min.empty() || value < _min.top())
        {
            _min.push(value);
        }
        else
        {
            _min.push(_min.top());
        }
    }
    void pop() {
        _min.pop();
        _data.pop();
    }
    int top() {
        return _data.top();
    }
    int min() {
        return _min.top();
    }
};
```



### 解法2：最小栈和数据栈元素个数不同

每次在入栈数据的时候，只有当前元素小于等于最小栈的栈顶元素时才将当前元素入栈到最小栈，但是在出栈的时候需要判断出栈的数据是否等于最小栈的栈顶元素，是的话让最小栈元素出栈

```cpp
class Solution {
private:
    stack<int> _data;
    stack<int> _min;
public:
    void push(int value) {
        _data.push(value);
        if(_min.empty() || value <= _min.top())
        {
            _min.push(value);
        }
    }
    void pop() {
        if(_min.top() == _data.top())
        {
            _min.pop();
        }
        _data.pop();
    }
    int top() {
        return _data.top();
    }
    int min() {
        return _min.top();
    }
};
```

## 18.栈的压入、弹出序列

<a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213163053590.png" alt="image-20211213163053590" style="zoom:50%;" />

**考察点：栈的特点，后进先出**

解题思路：

按照入栈序列让元素入栈，并用此时的栈顶元素和出栈序列进行匹配，如果此时的栈顶元素等于出栈序列的元素，让栈顶元素出栈，当把所有元素都入栈后，如果匹配成功，则栈会变为空，否则栈不为空

```cpp
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        if(pushV.empty() || popV.empty() || pushV.size() != popV.size())
        {
            return false;
        }
        
        stack<int> st;
        int popIdx = 0;
        for(int i = 0; i < pushV.size(); ++i)
        {
            st.push(pushV[i]);
            while(!st.empty() && st.top() == popV[popIdx])
            {
                st.pop();
                ++popIdx;
            }
        }
        
        return st.empty();
    }
};
```

## 19.二叉树的层序遍历

<a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213163714409.png" alt="image-20211213163714409" style="zoom:50%;" />

**考察点：二叉树的层序遍历**

**解题思路：**

使用队列存储二叉树节点，利用队列先进先出的特点，将二叉树的根节点入队，每次将当前队列中的所有元素出队并存储到结果集中，出队的同时将左右孩子存入队列，重复这一步直到队列为空，每次处理一层的同时，将下一层的节点按照从左到右的顺序入队，直到处理完所有层的节点

```cpp
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) {
        queue<TreeNode*> q;
        if(root)
        {
            q.push(root);
        }
        vector<int> levelOrderRes;
        while(!q.empty())
        {
            TreeNode* front = q.front();
            q.pop();
            levelOrderRes.push_back(front->val);
            
            if(front->left)
            {
                q.push(front->left);
            }
            if(front->right)
            {
                q.push(front->right);
            }
        }
        
        return levelOrderRes;
    }
};
```

## 20.二叉搜索树的后序遍历序列

<a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213164212480.png" alt="image-20211213164212480" style="zoom:50%;" />

**考察点：二叉搜索树性质的理解**

**解题思路：**

拿到后序序列的最后一个元素，以它为基准值，将后序序列划分为左右子树两部分，再分别判断左右子树的后序遍历序列是否有效

```cpp
class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        //题目规定空树不是二叉搜索树
        if(sequence.empty())
        {
            return false;
        }
        return VerifySquenceOfBSTHelper(sequence, 0, sequence.size() - 1);
    }
private:
    bool VerifySquenceOfBSTHelper(const vector<int>& postOrder, int begin, int end)
    {
        //起始位置大于结束位置，说明左子树不存在
        //起始位置等于结束位置，说明了这棵树只有一个节点
        if(begin >= end)
        {
            return true;
        }
        
        int rootVal = postOrder[end];
        int div = begin;
        //找到第一个大于根节点值的位置
        //这里的比较条件不能是等于，等于会陷入死循环
        while(div < end)
        {
            if(postOrder[div] > rootVal)
            {
                break;
            }
            ++div;
        }
        for(int idx = div; idx < end; ++idx)
        {
            if(postOrder[idx] < rootVal)
            {
                return false;
            }
        }
        
        return VerifySquenceOfBSTHelper(postOrder, begin, div - 1) 
            && VerifySquenceOfBSTHelper(postOrder, div, end - 1); 
    }
};
```

## 21.二叉树中和为某一值的路径

<a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213165004405.png" alt="image-20211213165004405" style="zoom:50%;" />

**考察点：回溯**

**解题思路：**

从根节点向叶节点出发，每遇到一个节点让目标值减去根节点的值，并且将当前节点的值插入数组中，直到到达叶节点并且目标值变为0，此时一轮查找结束，将结果保存到结果集中，回退，重复查找直到找到所有的结果

```cpp
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    vector<vector<int>> FindPath(TreeNode* root,int expectNumber) {
        vector<vector<int>> solutions;
        vector<int> solution;
        
        if(!root)
        {
            return solutions;
        }
        
        dfs(root, expectNumber, solution, solutions);
        
        return solutions;
    }
private:
    void dfs(TreeNode* root, int expectNumber,
             vector<int>& solution, vector<vector<int>>& solutions)
    {
        //递归出口
        if(!root)
        {
            return;
        }
        
        
        expectNumber -= root->val;
        solution.push_back(root->val);
        if(expectNumber == 0 && !root->left && !root->right)
        {
            solutions.push_back(solution);
        }
        
        //处理下一步
        dfs(root->left, expectNumber, solution, solutions);
        dfs(root->right, expectNumber, solution, solutions);
        
        //回退
        solution.pop_back();
    }
};
```

## 22.字符串的排列

<a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213170259840.png" alt="image-20211213170259840" style="zoom:50%;" />

**考察点：回溯**

**解题思路：**

把目标串理解成两部分：第一部分：以哪个字符开头，第二部分：剩下的是子问题 

所以，我们要让每个字符都要做一遍开头，然后再求解子问题

```cpp
class Solution {
public:
    vector<string> Permutation(string str) {
        vector<string> res;
        dfs(str, 0, res);
        return res;
    }
private:
    unordered_set<string> bank;    //借助set去重
    void dfs(string& str, int curIdx, vector<string>& res)
    {
        //递归出口
        if(curIdx == str.size() - 1)
        {
            //没有出现过就将其插入结果集
            if(bank.count(str) == 0)
            {
                res.push_back(str); 
                bank.insert(str);
            }
            return;
        }
        
        for(int i = curIdx; i < str.size(); ++i)
        {
            //处理当前元素
            swap(str, i, curIdx);
            //处理下一步
            dfs(str, curIdx + 1, res);
            //回退
            swap(str, i, curIdx);
        }
    }
    void swap(string& str, int pos1, int pos2)
    {
        char tmp = str[pos1];
        str[pos1] = str[pos2];
        str[pos2] = tmp;
    }
};
```

## 23.数组中出现次数超过一半的数字

<a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213171551954.png" alt="image-20211213171551954" style="zoom:50%;" />

**考察点：哈希 排序 数组**

### 解法1：哈希表统计词频

**解题思路：**

利用哈希表统计每个元素出现的次数，遍历哈希表找到出现次数大于数组大小一半的元素

```cpp
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        unordered_map<int, int> bank;
        int half = numbers.size() / 2;
        for(int i = 0; i < numbers.size(); ++i)
        {
            if(bank.count(numbers[i]))
            {
                ++bank[numbers[i]];
                if(bank[numbers[i]] > half)
                {
                    return numbers[i];
                }
            }
            else
            {
                ++bank[numbers[i]];
            }
        }
        
        //数组只有一个元素的情况需要特殊处理
        return numbers.size() == 1 ? numbers[0] : -1;
    }
};
```

### 解法2：排序

**解题思路：**

对数组按照从小到大排序，因为目标值出现次数大于数组长度的一半，所以中间位置的元素一定是目标值，统计中间位置元素出现的次数，判断是否满足条件

```cpp
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        sort(numbers.begin(), numbers.end());
        
        int half = numbers.size() / 2;
        int target = numbers[(numbers.size() - 1) / 2];
        int cnt = 0;
        for(int i = 0; i < numbers.size(); ++i)
        {
            if(target == numbers[i])
            {
                ++cnt;
            }
        }
        
        return cnt > half ? target : -1;
    }
};
```

### 解法3：打擂法

**解题思路：**

让第一个元素作为擂主，设置己方人数为1，从第二个元素开始遍历直到数组最后一个元素，

如果当前元素的值等于擂主的值，让己方人数+1，

如果当前元素的值不等于擂主的值，让己方人数-1，如果己方人数减为0，更新下一个元素为擂主，将己方人数设置为1。

当打擂结束，统计擂主在数组中出现的次数，判断是否大于数组长度的一半

```cpp
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        if(numbers.empty())
        {
            return -1;
        }
        
        int len = numbers.size();
        int winner = numbers[0];    //初始化擂主
        int winCnt = 1;             //己方人数为1
        //1.打擂
        for(int i = 1; i < len; ++i)
        {
            //更换擂主
            if(winCnt == 0)
            {
                winner = numbers[i];
                winCnt = 1;
            }
            
             if(numbers[i] == winner)
             {
                 //数值相同，己方人数+1
                 ++winCnt;
             }
            else
            {
                 //数值不同，己方人数-1
                --winCnt;
            }
        }
        
        winCnt = 0;
        //2.统计擂主一方的人数
        for(int i = 0; i < len; ++i)
        {
            if(numbers[i] == winner)
            {
                ++winCnt;
            }
        }
        
        return winCnt > len / 2 ? winner : -1;
    }
};
```

## 24.最小的K个数

<a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213181828699.png" alt="image-20211213181828699" style="zoom:50%;" />

**考察点：堆的使用**

### 解法1：建小堆

解题思路：建一个小堆，取堆顶的k个元素

```cpp
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        if(k == 0 || k > input.size())
        {
            return vector<int>();
        }
        
       priority_queue<int, vector<int>, greater<int>> q;        //建一个小堆
       for(int i = 0; i < input.size(); ++i)
       {
           q.push(input[i]);
       }

        vector<int> res;
        if(q.size() < k)
        {
            return res;   
        }
        while(k--)
        {
            res.push_back(q.top());
            q.pop();
        }
        
        return res;
    }
};
```

### 解法2：建大堆

解题思路：建一个大堆，让这个堆中始终只有k个元素，先让数组中的前k个元素入堆，再让其他元素和堆顶元素比较，如果小于堆顶元素，让堆顶元素出堆

```cpp
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        if(k == 0 || k > input.size())
        {
            return vector<int>();
        }
        
        priority_queue<int> q;        //建一个大堆
        int cnt = 0;
        for(int i = 0; i < input.size(); ++i)
        {
            //将前k个元素入堆
            if(cnt < k)
            {
                q.push(input[i]);
            }
            else
            {
                if(input[i] < q.top())
                {
                    q.pop();
                    q.push(input[i]);
                }
            }
            ++cnt;
        }
        
        vector<int> res;
        
        while(!q.empty())
        {
            res.push_back(q.top());
            q.pop();
        }
        
        return res;
    }
};
```

## 25.连续子数组的最大和

<a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213182857984.png" alt="image-20211213182857984" style="zoom:50%;" />

**考察点：动态规划**

**解题思路：**

计算以当前下标结尾的每一项的最大和，除了第一项的最大和是自身外，每一项的最大和等于当前项的值加上前一项的值和当前项的值中的较大值，比较每一项的最大值得到其中的最大值就是结果

```cpp
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        int maxSum = array[0], curSum = array[0];
        for(int i = 1; i < array.size(); ++i)
        {
            if(curSum > 0)
            {
                curSum += array[i];
            }
            else
            {
                curSum = array[i];
            }
            if(curSum > maxSum)
            {
                maxSum = curSum;
            }
        }
        
        return maxSum;
    }
};
```

## 26.回文串索引

<a href="https://www.nowcoder.com/practice/b6edb5ca15d34b1eb42e4725a3c68eba?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213183738522.png" alt="image-20211213183738522" style="zoom:50%;" />

**考察点：回文的特性**

**解题思路：**

从字符串的头部和尾部开始扫描，

如果两个位置的元素相等，向中间移动；

如果不相等，左右两边必定有一个是目标位置，先删除左边位置的元素，判断执行删除操作之后的字符串是否为回文结构，如果是回文结构，则左边位置就是目标位置，如果不是则右边位置是目标位置

```cpp
#include <iostream>
#include <string>

using namespace std;

//这份代码简直美如画
bool isPalinDrome(string& str, int begin, int end)
{
    while(begin < end)
    {
        if(str[begin] != str[end])
            return false;
        begin++;
        end--;
    }
    return true;
}

int findDelPos(string& str)
{
    int left = 0, right = str.size() - 1;
    int pos = -1;
    
    //1.判断是否已经是回文字符串
    if(isPalinDrome(str, 0, str.size() - 1))
    {
        return pos;
    }
    
    //2.双指针进行查找
    while(left < right)
    {
        if(str[left] == str[right])
        {
            ++left;
            --right;
        }
        else
        {
            str.erase(left, 1);
            if(isPalinDrome(str, 0, str.size() - 1))
            {
                pos = left;
                break;
            }
            else
            {
                pos = right;
                break;
            }
        }
    }
    
    return pos;
}

int main()
{
    int n;
    cin >> n;
    string str;
    
    while(n--)
    {
        str.clear();
        cin >> str;
  
        if(isPalinDrome(str, 0, str.size() - 1))
            cout << -1 << endl;
        else
            cout << findDelPos(str) << endl;
    }
    
    return 0;
}
```

## 27.将数组排列成最小的数

<a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213184624424.png" alt="image-20211213184624424" style="zoom:50%;" />

**考察点:排序算法**

**解题思路：**

1. 对数组进行排序，排序的规则是：

将数字转换为字符串，让两个字符串分别在末尾累加对方，让累加后值更小的排列在前面

2. 将排序后的数组元素，从头到尾转换为字符串并进行累加

```cpp
class Solution {
public:
    struct Cmp
    {
        bool operator()(int a, int b)
        {
            string sa(to_string(a)), sb(to_string(b));
            string sab = sa + sb;
            string sba = sb + sa;
            return sab < sba;
        }
    };
    
    string PrintMinNumber(vector<int> numbers) {
        sort(numbers.begin(), numbers.end(), Cmp());
        
        string res;
        for(int i = 0; i < numbers.size(); ++i)
        {
            res += to_string(numbers[i]);
        }
        
        return res;
    }
};
```

## 28.两个单链表的第一个公共节点

<a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213185214836.png" alt="image-20211213185214836" style="zoom:67%;" />

**考察点：单链表结构**

### 解法1：让长的链表先走两个链表长度的差值步，两个链表的指针同时向后更新，查找第一个公共节点

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* head1, ListNode* head2) {
        if(!head1 || !head2)
        {
            return nullptr;
        }
        
        int len1 = getListLen(head1);
        int len2 = getListLen(head2);
        int gap = len1 - len2;
        if(gap > 0)
        {
            while(gap--)
            {
                head1 = head1->next;
            }
        }
        else
        {
            gap = -gap;
            while(gap--)
            {
                head2 = head2->next;
            }
        }
        
        while(head1 && head2)
        {
            if(head1 == head2)
            {
                break;
            }
            head1 = head1->next;
            head2 = head2->next;
        }
        
        //如果有公共节点，返回公共节点，如果没有返回空节点
        return head1;
    }
private:
    //获取链表长度
    int getListLen(ListNode* head)
    {
        int len = 0;
        while(head)
        {
            ++len;
            head = head->next;
        }
        return len;
    }
};
```

### 解法2：两个链表分别在尾部追加另一个链表，进而长度相等，从头开始查找

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* head1, ListNode* head2) {
        if(!head1 || !head2)
        {
            return nullptr;
        }
        
        ListNode *node1 = head1, *node2 = head2;
        while(node1 != node2)
        {
            //当前节点不为空，更新到下一个节点
            //当前节点为空，更新到另一个链表的头节点
            node1 = node1 ? node1->next : head2;
            node2 = node2 ? node2->next : head1;
        }
        
        //走到这里有两种结果，一种是找到了第一个公共节点，一种是两个链表节点同时走到了空节点处退出循环
        return node1;
    }
};
```

## 29.二叉树的深度

<a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213191030785.png" alt="image-20211213191030785" style="zoom:50%;" />

**考察点：二叉树的深度，层序遍历**

二叉树的深度从高到低看

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213192355667.png" alt="image-20211213192355667" style="zoom:50%;" />

### 解法1：递归

**解题思路:**

从根节点开始，初始化为根节点深度为0，每往下一层，深度加1，直到到达空节点，此时空节点对应的深度就是叶子节点的深度，找到所有叶子节点深度的最大值就是树的深度

```cpp
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    int TreeDepth(TreeNode* root) {
        int maxDepth = 0, curDepth = 0;
        TreeDepthHelper(root, maxDepth, curDepth);
        return maxDepth;
    }
private:
    void TreeDepthHelper(TreeNode* root, int& maxDepth, int curDepth)
    {
        //走到空节点位置，才能拿到叶子节点的深度
        if(!root)
        {
            if(curDepth > maxDepth)
            {
                maxDepth = curDepth;
            }
            return;
        }
        
        TreeDepthHelper(root->left, maxDepth, curDepth + 1);
        TreeDepthHelper(root->right, maxDepth, curDepth + 1);
    }
};
```

### 解法2：层序遍历

解题思路：层序遍历的次数就是二叉树的深度

```cpp
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    int TreeDepth(TreeNode* pRoot) {
        int depth = 0;
        queue<TreeNode*> q;
        if(pRoot)
        {
            q.push(pRoot);            
        }
        
        while(!q.empty())
        {
            int sz = q.size();
            while(sz--)
            {
                TreeNode* front = q.front();
                q.pop();
                if(front->left)
                {
                    q.push(front->left);
                }
                if(front->right)
                {
                    q.push(front->right);
                }
            }
            ++depth;    //每扫描一层，深度+1
        }
        
        return depth;
    }
};
```

## 30.数组中只出现一次的数字

<a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?">Link</a>

**题目简介：**

![image-20211213192833978](C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213192833978.png)

**解题思路：**

数组中只有两个元素唯一出现一次，其他元素都出现了两次，将所有元素异或得到的结果就是唯一出现的两个元素异或后的值，通过对这个值进行计算，得到最低的比特位为1对应的数字；

根据这个数字，对所有元素划分小组，该比特位为1的进入第一组，否则进入第二组，相同的元素会进入同一组，将两组中所有的元素异或就可以消除出现次数为2次的元素，最终每一组中只剩下唯一出现的元素

```cpp
class Solution {
public:
    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
        if(!num1 || !num2)
        {
            return;
        }
        
        int XORRes = 0;        //初始化为0，0异或任何数等于任何数
        //1.将所有元素进行异或，最终的结果就是两个只出现一次的数字异或的结果
        for(int i = 0; i < data.size(); ++i)
        {
            XORRes ^= data[i];
        }
        
        //2.找到异或后的结果最低位为1的对应的数
        int differ = 1;
        while(1)
        {
            if(differ & XORRes)
            {
                break;
            }
            differ <<= 1;
        }
        
        //3.根据最低位为1的数堆数据进行划分,该比特位为1的是同一组，否则是另外一组
        *num1 = 0;    //初始化为0，0异或任何数等于任何数
        *num2 = 0;    //初始化为0，0异或任何数等于任何数
        for(int i = 0; i < data.size(); ++i)
        {
            if(data[i] & differ)
            {
                *num1 ^= data[i];
            }
            else
            {
                *num2 ^= data[i];
            }
        }
    }
};
```

## 31.和为S的连续正数序列

<a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213193823728.png" alt="image-20211213193823728" style="zoom:50%;" />

**考察点：滑动窗口(双指针)**

**解题思路：**

通过两个指针维持一个窗口，一个是窗口前沿，一个是窗口后沿，

当窗口内的元素之和等于目标值时，将窗口内的元素构造成一个结果插入结果集，同时让窗口后沿向前移动；

当窗口内的元素之和大于目标值时，将窗口后沿向前移动，缩小窗口；

当窗口内的元素之和小于目标值时，将窗口前沿向前移动，扩大窗口；

让窗口不断更新，直到前沿和后沿有一方到达末尾

```cpp
class Solution {
public:
    vector<vector<int> > FindContinuousSequence(int sum) {
        vector<vector<int>> allSolutions;
        vector<int> solution;
        if (sum == 0)
        {
            return allSolutions;
        }

        int front = 1;        //滑动窗口前沿，靠近sum的那一侧
        int rear = 1;         //滑动窗口后沿，靠近1的那一侧
        int curSum = 1;
        while (front < sum && rear < sum)
        {
            curSum = (front + rear) * (front - rear + 1) / 2;
            if (curSum > sum)
            {
                //区间元素总和大于目标值，区间后沿向前移动，缩小区间范围
                ++rear;
            }
            else if (curSum < sum)
            {
                //区间元素总和小于目标值，区间前沿向前移动，扩大区间范围
                ++front;
            }
            else
            {
                solution.clear();
                //找到了目标值，将区间内的元素插入结果集
                for (int i = rear; i <= front; ++i)
                {
                    solution.push_back(i);
                }
                allSolutions.push_back(solution);
                ++rear;        //从当前区间后沿的下一个位置开始新一轮查找
            }
        }

        return allSolutions;
    }
};
```

## 32.左旋转字符串

<a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213194740826.png" alt="image-20211213194740826" style="zoom:50%;" />

**考察点：字符串处理**

### 解法1：每次左移一位，移动k次数

```cpp
class Solution {
public:
    string LeftRotateString(string str, int n) {
        if(str.empty())
        {
            return str;
        }
        
        int len = str.size();
        n %= len;        //减少重复运算
        
        while(n--)
        {
            remoteLeftOneStep(str);
        }
        return str;
    }
private:
    void remoteLeftOneStep(string& str)
    {
        char head = str[0];    //保存首元素
        //将首元素后面的所有元素向前移动一位
        for(int i = 0; i < str.size() - 1; ++i)
        {
            str[i] = str[i + 1];
        }
        //将首元素添加到尾部
        str[str.size() - 1] = head;
    }
};
```

### 解法2：给字符串末尾再累加一个自身，从第k个字符开始截取原字符串长度个字符

```cpp
class Solution {
public:
    string LeftRotateString(string str, int n) {
        if(str.empty())
        {
            return str;
        }
        
        int len = str.size();
        n %= len;        //减少重复运算
        
        str += str;      //在当前字符串的末尾追加一个自身
        
        string res = str.substr(n, len);
        return res;
    }
};
```

### 解法3：分别反转前k个字符和后面的字符串，再整体反转

解题思路：

先局部反转，再整体反转

局部反转的作用在于将元素的顺序逆置，整体反转的作用在于将前面的k个元素和后面的元素调整位置

```cpp
class Solution {
public:
    string LeftRotateString(string str, int n) {
        if(str.empty() || n == 0)
        {
            return str;
        }
        n %= str.size();
        
        Reverse(str, 0, n - 1);
        Reverse(str, n, str.size() - 1);
        Reverse(str, 0, str.size() - 1);
        
        return str;
    }
private:
    //反转字符串
    void Reverse(string& str, int begin, int end)
    {
        while(begin < end)
        {
            char tmp = str[begin];
            str[begin] = str[end];
            str[end] = tmp;
            ++begin;
            --end;
        }
    }
};
```

## 33.翻转单词序列

<a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?">Link</a>

**题目简介**：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213200238741.png" alt="image-20211213200238741" style="zoom:50%;" />

**考察点：字符串处理**

**解题思路：**

反转每一个单词，再反转整体字符串

```cpp
class Solution {
public:
    string ReverseSentence(string str) {
        int begin = 0, end = 0;
        while(end < str.size())
        {
            //走到下一个空格的位置
            while(end < str.size() && str[end] != ' ')
            {
                ++end;
            }
            
            //反转单词
            Reverse(str, begin, end - 1);
            
            //走到下一个单词的起始位置
            while(end < str.size() && str[end] == ' ')
            {
                ++end;
            }
            //更新单词的起始位置
            begin = end;
        }
        //反转最后一个未处理的单词
        Reverse(str, begin, end - 1);
        
        //整体反转
        Reverse(str, 0, str.size() - 1);
        
        return str;
    }
private:
    //反转字符串
    void Reverse(string& str, int begin, int end)
    {
        while(begin < end)
        {
            char tmp = str[begin];
            str[begin] = str[end];
            str[end] = tmp;
            ++begin;
            --end;
        }
    }
};
```

## 34.二叉树的之字形打印

<a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?">Link</a>

**题目简介：**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213200629896.png" alt="image-20211213200629896" style="zoom:50%;" />

**考察点：层序遍历、栈的使用**

### 解法1：根据层数判断是否需要逆置字符串

解题思路：

根据层数判断本层遍历结果是否需要逆置，如果是奇数层不需要逆置，如果是偶数层需要逆置

```cpp
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/

//两个栈进行切换,避免调用栈混乱
class Solution {
public:
    vector<vector<int> > Print(TreeNode* root) {
        vector<vector<int>> allLevels;
        vector<int> level;
        
        queue<TreeNode*> q;
        if(root)
        {
            q.push(root);
        }
        
        int depth = 0;
        
        while(!q.empty())
        {
           level.clear();
            ++depth;
           int sz = q.size();
           while(sz--)
           {
               TreeNode* front = q.front();
               q.pop();
               level.push_back(front->val);
               
               if(front->left)
               {
                   q.push(front->left);
               }
               if(front->right)
               {
                   q.push(front->right);
               }
           }
           //偶数层反转本轮遍历结果
           if(depth % 2 == 0)
           {
               reverse(level.begin(), level.end());
           }
           allLevels.push_back(level);
        }
        
        return allLevels;
    }
};
```

### 解法2：队列辅助栈

解题思路：

栈存储这一轮访问的数据，队列临时保存存放下一轮访问的数据,这一轮出栈的顺序就是下一轮入栈的顺序

```cpp
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/

//两个栈进行切换,避免调用栈混乱
class Solution {
public:
    vector<vector<int> > Print(TreeNode* root) {
        vector<vector<int>> allLevels;
        vector<int> level;
        
        stack<TreeNode*> st;
        queue<TreeNode*> q;
        if(root)
        {
            st.push(root);
        }
        
        int dir = 1;               //上一层节点出栈的顺序，1表示从左到右访问
        while(!st.empty())
        {
           level.clear();
           int sz = st.size();
           while(sz--)
           {
               TreeNode* topNode = st.top();
               st.pop();
               level.push_back(topNode->val);
               
               TreeNode* first = dir == 1 ? topNode->left : topNode->right;
               TreeNode* second = dir == 1 ? topNode->right : topNode->left;
               if(first)
               {
                   q.push(first);
               }
               if(second)
               {
                   q.push(second);
               }
           }
           allLevels.push_back(level);
           dir = dir == 1 ? 2 : 1;
           while(!q.empty())
           {
               st.push(q.front());
               q.pop();
           }
        }
        
        return allLevels;
    }
};
```

### 解法3：两个栈切换

解题思路：

一个栈存储这一轮访问的数据，一个栈存储下一轮访问的数据，,这一轮出栈的顺序就是下一轮入栈的顺序，两个栈之间进行切换

```cpp
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/

//两个栈进行切换,避免调用栈混乱
class Solution {
public:
    vector<vector<int> > Print(TreeNode* root) {
        vector<vector<int>> allLevels;
        vector<int> level;
        
        stack<TreeNode*> st[2];
        int curIdx = 0, nextIdx = 1;
        if(root)
        {
            st[curIdx].push(root);
        }
        int dir = 1;               //上一层节点出栈的顺序，1表示从左到右访问
        while(!st[curIdx].empty())
        {
           level.clear();
           int sz = st[curIdx].size();
           while(sz--)
           {
               TreeNode* topNode = st[curIdx].top();
               st[curIdx].pop();
               level.push_back(topNode->val);
               
               TreeNode* first = dir == 1 ? topNode->left : topNode->right;
               TreeNode* second = dir == 1 ? topNode->right : topNode->left;
               if(first)
               {
                   st[nextIdx].push(first);
               }
               if(second)
               {
                   st[nextIdx].push(second);
               }
           }
           allLevels.push_back(level);
           dir = dir == 1 ? 2 : 1;
           curIdx = 1 - curIdx;
           nextIdx = 1 - nextIdx;
        }
        
        return allLevels;
    }
};
```

## 35.二叉搜索树第k小的节点

<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">Link</a>

**题目简介：**

![image-20211213201939999](C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211213201939999.png)

**考察点：二叉搜索树性质**

**解题思路：**

对二叉搜索树进行中序遍历，中序遍历的第k个节点，就是目标节点

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        if(!root)
        {
            return -1;
        }

        stack<TreeNode*> st;
        TreeNode* curNode = root;
        while(!st.empty() || curNode)
        {
            while(curNode)
            {
                st.push(curNode);
                curNode = curNode->left;
            }

            TreeNode* top = st.top();
            st.pop();
            k--;

            if(k == 0)
            {
                return top->val;
            }

            curNode = top->right;
        }

        //k大于树中节点个数，返回-1
        return -1;
    }
};
```

