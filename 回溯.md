@[TOC](回溯算法刷题)

# 回溯的初步认识

​		回溯是一种类似枚举的搜索尝试过程，在搜索尝试中寻找问题的解，如果不满足求解条件就返回，尝试其他的选择，适用于规模不大的问题，根据搜索策略的不同可以分为深度优先搜索(dfs)和广度优先搜索(bfs)两种类型

# 一.深度优先搜索

​		深度优先搜索是一种一条路走到黑的搜索方式，当这条路径不满足求解条件就一层层向上返回

**dfs模型**

```cpp
void dfs()
{
	//递归出口
	//处理当前路径
	//处理下一步
	//回退
}
```

## 1.员工的重要性

<a href="https://leetcode-cn.com/problems/employee-importance/">link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225194540283.png" alt="image-20211225194540283" style="zoom:50%;" />

****

代码:

```cpp
/*
// Definition for Employee.
class Employee {
public:
    int id;
    int importance;
    vector<int> subordinates;
};
*/

class Solution {
public:
    int getImportance(vector<Employee*> employees, int id) {
        map<int, Employee*> id_info;
        //1.建立员工的id和自身信息的映射关系
        for(const auto& info : employees)
        {
            id_info[info->id] = info;
        }

        //2.从当前员工向下级进行深度优先搜索
        return dfs(id_info, id);
    }
private:
    int dfs(map<int, Employee*>& id_info, int id)
    {
        //累加自身的重要性
        int sum = id_info[id]->importance;
        for(int subId : id_info[id]->subordinates)
        {
            //累加孩子的重要性
            sum += dfs(id_info, subId);
        }
        return sum;
    }
};
```

## 2.图像渲染

<a href="https://leetcode-cn.com/problems/flood-fill/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225194839171.png" alt="image-20211225194839171" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int oldColr = image[sr][sc];
        int row = image.size();
        int col = image[0].size();
        vector<vector<bool>> visited(row, vector<bool>(col, false));
        dfs(image, row, col, visited, sr, sc, oldColr, newColor);
        return image;
    }
private:
    int nextStep[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};        //四个移动方向
    void dfs(vector<vector<int>>& image, int row, int col, 
        vector<vector<bool>>& visited, int sr, int sc, int oldColr, int newColor)
    {
        visited[sr][sc] = true;
        image[sr][sc] = newColor;
        for(int i = 0; i < 4; ++i)
        {
            int curX = sr + nextStep[i][0];
            int curY = sc + nextStep[i][1];
            if(curX < 0 || curX >= row || curY < 0 || curY >= col 
                || visited[curX][curY])
            {
                continue;
            }
            if(image[curX][curY] == oldColr)
            {
                dfs(image, row, col, visited, curX, curY, oldColr, newColor);
            }
        }
    }
};
```

## 3.岛屿的周长

<a href="https://leetcode-cn.com/problems/island-perimeter/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225195050848.png" alt="image-20211225195050848" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int rows = grid.size(), cols = grid[0].size();
        for(int i = 0; i < rows; ++i)
        {
            for(int j = 0; j < cols; ++j)
            {
                //只有一个岛，从任何一个位置登陆都可以扫描整个岛
                if(grid[i][j] == 1)
                {
                    return dfs(grid, rows, cols, i, j);
                }
            }
        }

        //程序不会走到这里，只是为了通过编译
        return -1;
    }
private:
    int nextStep[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};
    int dfs(vector<vector<int>>& grid, int rows, int cols, int sr, int sc)
    {
        //下标越界或者当前位置是水域，则周长+1
        if(sr < 0 || sr >= rows || sc < 0 || sc >= cols || grid[sr][sc] == 0)
        {
            return 1;
        }
        //访问的是已经访问的陆地，返回0
        if(grid[sr][sc] == 2)
        {
            return 0;
        }

        //标记当前位置已经访问过
        grid[sr][sc] = 2;

        int sum = 0;
        for(int i = 0; i < 4; ++i)
        {
            int curX = sr + nextStep[i][0];
            int curY = sc + nextStep[i][1];

            sum += dfs(grid, rows, cols, curX, curY);
        }

        return sum;
    }
};
```

## 4.被围绕的区域

<a href="https://leetcode-cn.com/problems/surrounded-regions/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225195256782.png" alt="image-20211225195256782" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        int rows = board.size(), cols = board[0].size();
        vector<vector<bool>> visited(rows, vector<bool>(cols, false));
        //1.从边上出发将能到达的O替换为A
        for(int i = 0; i < rows; ++i)
        {
            //！！！！！！！！！！！！！！！！！！
            //这里两个if应该是串行的，我却写成了if else if的结构，导致逻辑错误
            //从第一列和最后一列出发
            if(board[i][0] == 'O' && !visited[i][0])
            {
                dfs(board, rows, cols, visited, i, 0);
            }
            if(board[i][cols - 1] == 'O' && !visited[i][cols - 1])
            {
                dfs(board, rows, cols, visited, i, cols - 1);
            }
        }
        for(int i = 0; i < cols; ++i)
        {
            //！！！！！！！！！！！！！！！！！！
            //这里两个if应该是串行的，我却写成了if else if的结构，导致逻辑错误
            //从第一行和最后一行出发
            if(board[0][i] == 'O' && !visited[0][i])
            {
                dfs(board, rows, cols, visited, 0, i);
            }
            if(board[rows - 1][i] == 'O' && !visited[rows - 1][i])
            {
                dfs(board, rows, cols, visited, rows - 1, i);
            }
        }

        //2.将所有的O替换为X
        for(int i = 0; i < rows; ++i)
        {
            for(int j = 0; j < cols; ++j)
            {
                if(board[i][j] == 'O')
                {
                    board[i][j] = 'X';
                }
            }
        }

        //3.将A替换回O
        for(int i = 0; i < rows; ++i)
        {
            for(int j = 0; j < cols; ++j)
            {
                if(board[i][j] == 'A')
                {
                    board[i][j] = 'O';
                }
            }
        }
    }
private:
    int nextStep[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};
    void dfs(vector<vector<char>>& board, int rows, int cols, 
        vector<vector<bool>>& visited, int sr, int sc)
    {
        visited[sr][sc] = true;
        board[sr][sc] = 'A';

        for(int i = 0; i < 4; ++i)
        {
            int curX = sr + nextStep[i][0];
            int curY = sc + nextStep[i][1];

            if(curX < 0 || curX >= rows || curY < 0 || curY >= cols)
            {
                continue;
            }
            if(board[curX][curY] == 'O' && !visited[curX][curY])
            {
                dfs(board, rows, cols, visited, curX, curY);            
            }
        }
    }
};
```

## 5.岛屿数量

<a href="https://leetcode-cn.com/problems/number-of-islands/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225195440041.png" alt="image-20211225195440041" style="zoom:50%;" />

代码：

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int rows = grid.size(), cols = grid[0].size();
        vector<vector<bool>> visited(rows, vector<bool>(cols, false));
        int num = 0;
        for(int i = 0; i < rows; ++i)
        {
            for(int j = 0; j < cols; ++j)
            {
                //一次渲染一个岛屿，dfs渲染的次数就是岛屿的个数
                if(grid[i][j] == '1' && !visited[i][j])
                {
                    dfs(grid, rows, cols, visited, i, j);
                    ++num;
                }
            }
        }

        return num;
    }
private:
    int nextStep[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};
    void dfs(vector<vector<char>>& grid, int rows, int cols, 
        vector<vector<bool>>& visited, int sr, int sc)
    {
        visited[sr][sc] = true;
        for(int i = 0; i < 4; ++i)
        {
            int curX = sr + nextStep[i][0];
            int curY = sc + nextStep[i][1];
            if(curX < 0 || curX >= rows || curY < 0 || curY >= cols)
            {
                continue;
            }
            if(grid[curX][curY] == '1' && !visited[curX][curY])
            {
                dfs(grid, rows, cols, visited, curX, curY);
            }
        }
    }
};
```

## 6.岛屿的最大面积

<a href="https://leetcode-cn.com/problems/max-area-of-island/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225195616881.png" alt="image-20211225195616881" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int maxArea = 0;
        int rows = grid.size(), cols = grid[0].size();

        for(int i = 0; i < rows; ++i)
        {
            for(int j = 0; j < cols; ++j)
            {
                //对所有岛屿的面积比较得到最大值
                if(grid[i][j] == 1)
                {
                    maxArea = max(maxArea, getIslandArea(grid, rows, cols, i, j));
                }
            }
        }

        return maxArea;
    }
private:
    const int nextStep[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    //获取单个岛屿的面积
    int getIslandArea(vector<vector<int>>& grid, int rows, int cols, int sr, int sc)
    {
        //这里的递归结束条件是最重要的
        if(grid[sr][sc] == 0)
        {
            return 0;
        }

        grid[sr][sc] = 0;     //原地进行标记，如果已经访问过，则标记为0
        int sum = 1;
        //向上下左右四个方向进行发散
        for(int i = 0; i < 4; ++i)
        {
            int curX = sr + nextStep[i][0];
            int curY = sc + nextStep[i][1];

            if(curX < 0 || curX >= rows || curY < 0 || curY >= cols)
            {
                continue;
            }

            sum += getIslandArea(grid, rows, cols, curX, curY);
        }

        return sum;
    }
};
```

## 7.电话号码的组合

<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225195747975.png" alt="image-20211225195747975" style="zoom:50%;" />

代码：

```cpp
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        //1.初始化哈希表，建立数字字符和对应字符串的映射关系
        digit_Str['2'] = "abc";
        digit_Str['3'] = "def";
        digit_Str['4'] = "ghi";
        digit_Str['5'] = "jkl";
        digit_Str['6'] = "mno";
        digit_Str['7'] = "pqrs";
        digit_Str['8'] = "tuv";
        digit_Str['9'] = "wxyz";

        //2.进行深度优先搜索
        string curStr;
        vector<string> res;
        
        dfs(digits, res, curStr, 0);

        return res;
    }
private:
    unordered_map<char, string> digit_Str;  //数字字符和对应的字符串的映射关系
    void dfs(const string& digits, vector<string>& res, string curStr, int curIdx)
    {
        //递归出口
        if(curIdx == digits.size())
        {
            //如果curStr为空，说明输入是一个空字符串，不能插入结果集
            if(!curStr.empty())
            {
                res.push_back(curStr);
            }
            return;
        }
        
        char curDigit = digits[curIdx];     //当前下标对应的数字字符
        //对数字字符对应的字母字符分别进行组合
        for(char ch : digit_Str[curDigit])
        {
            dfs(digits, res, curStr + ch, curIdx + 1);
        }
    }
};
```

## 8.组合

<a href="https://leetcode-cn.com/problems/combinations/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211226192933977.png" alt="image-20211226192933977" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        dfs(n, k, 1);

        return solutions;
    }
private:
    vector<vector<int>> solutions;
    vector<int> solution;

    void dfs(int n, int k, int curNum)
    {
        //判断k的值是否过大
        if(solution.size() + n - curNum + 1 < k)
        {
            return;
        }

        //递归出口
        if(solution.size() == k)
        {
            solutions.push_back(solution);
            return;
        }

        //1.选择放置当前元素
        solution.push_back(curNum);
        dfs(n, k, curNum + 1);
        solution.pop_back();

        //2.选择不放置当前元素
        dfs(n, k, curNum + 1);
    }
};
```

## 9.二进制手表

<a href="https://leetcode-cn.com/problems/binary-watch/">Link</a>

题目介绍：
<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225195941011.png" alt="image-20211225195941011" style="zoom:50%;" />

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225195956226.png" alt="image-20211225195956226" style="zoom:50%;" />

### 解法1：暴力求解

```cpp
class Solution {
public:
    vector<string> readBinaryWatch(int turnedOn) {
        vector<string> res;
        for(int hour = 0; hour < 12; ++hour)
        {
            for(int minute = 0; minute < 60; ++minute)
            {
                //如果时间和分钟中二进制中1的位数之和等于LED灯的数量，进行结果的组合
                if(countOf1(hour) + countOf1(minute) == turnedOn)
                {
                    string curTime(to_string(hour));
                    curTime += ":";
                    curTime += minute < 10 ? ("0" + to_string(minute)) : to_string(minute);
                    res.push_back(curTime);
                }
            }
        }

        return res;
    }
private:
    int countOf1(int num)
    {
        int cnt = 0;
        while(num > 0)
        {
            ++cnt;
            num &= (num - 1);
        }
        return cnt;
    }
};
```

### 解法2：dfs

dfs解法我没理解

```cpp
class Solution {
public:
    vector<string> ans;
    vector<string> readBinaryWatch(int num) {
        DFS(num, 0, vector<int>(10));
        return ans;
    }
private:
    //num:当前的LED灯数量
    //pos:
    //time：每盏灯的数量
    void DFS(int num, int pos, vector<int>time) {
        //递归结束条件
        if (num == 0) {
            int hour = time[0] + 2 * time[1] + 4 * time[2] + 8 * time[3];
            int minute = time[4] + 2 * time[5] + 4 * time[6] + 8 * time[7] + 16 * time[8] + 32 * time[9];
            //时间符合规范就将其进行组合
            if (hour < 12 && minute < 60) {
                string time(to_string(hour));
                time += ":";
                time += (minute < 10) ? ("0" + to_string(minute)) : to_string(minute);
                ans.push_back(time);
            }
            return;
        }

        //搞懂这个条件是关键
        for (int i = pos; i <= 10 - num; i++) {
            time[i]++;
            DFS(num-1, i + 1, time);
            time[i]--;
        }
    }
};
```

## 10.组合总和I

<a href="https://leetcode-cn.com/problems/combination-sum/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225200303406.png" alt="image-20211225200303406" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> solutions;
        vector<int> solution;

        dfs(candidates, target, 0, 0, solution, solutions);
        return solutions;
    }
private:
    void dfs(const vector<int>& candidates, int target, int curSum, int start, 
        vector<int>& solution, vector<vector<int>>& solutions)
    {
        if(curSum >= target)
        {
            if(curSum == target)
            {
                solutions.push_back(solution);
            }
            return;
        }

        for(int i = start; i < candidates.size(); ++i)
        {
            solution.push_back(candidates[i]);
            dfs(candidates, target, curSum + candidates[i], i, solution, solutions);
            solution.pop_back();
        }
    }
};
```

## 11.组合总和II

<a href="https://leetcode-cn.com/problems/combination-sum-ii/">Link</a>

题目介绍：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211226193139276.png" alt="image-20211226193139276" style="zoom:50%;" />

代码：

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());     //从小到大排序
        //统计频次信息
        for(int num : candidates)
        {
            //当前元素没有出现过，将其插入频次信息表中
            if(freq.empty() || freq.back().first != num)
            {
                freq.push_back(make_pair(num, 1));
            }
            //累加元素频次信息
            else
            {
                ++freq.back().second;
            }
        }
        //进行深度优先搜索
        dfs(0, target);

        return solutions;
    }
private:
    vector<vector<int>> solutions;          //结果集
    vector<int> solution;                   //一条结果
    vector<pair<int, int>> freq;            //存储频次信息
    void dfs(int pos, int rest)
    {
        //递归出口
        if(rest == 0)
        {
            solutions.push_back(solution);
            return;
        }
        //不满足放置元素的条件，直接退出
        if(pos == freq.size() || rest < freq[pos].first)
        {
            return;
        }

        //第一种选择：不放置当前元素
        dfs(pos + 1, rest);

        //第二种选择：放置当前元素
        int most = min(rest / freq[pos].first, freq[pos].second);
        for(int i = 1; i <= most; ++i)
        {
            solution.push_back(freq[pos].first);
            dfs(pos + 1, rest - i * freq[pos].first);          
        }
        //回退
        for(int i = 1; i <= most; ++i)
        {
            solution.pop_back();
        }
    }
};
```

## 12.组合总和III

<a href="https://leetcode-cn.com/problems/combination-sum-iii/">Link</a>

题目介绍：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211228163209810.png" alt="image-20211228163209810" style="zoom:50%;" />

代码：

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int target) {
        //从1~9分别进行深度优先搜索
        for(int i = 1; i <= 9; ++i)
        {
            dfs(target, 0, i, k);     
        }

        return solutions;
    }
private:
    vector<int> solution;               //一种可行的组合
    vector<vector<int>> solutions;      //所有可行的组合

    //target:目标数字
    //curSum:当前元素总和
    //start:当前元素
    //k:组合中剩余的位置个数
    void dfs(int target, int curSum, int start, int k)
    {
        //累加当前元素
        curSum += start;
        //将当前元素放入结果
        solution.push_back(start);
        //递归出口
        if (curSum >= target)
        {
            //元素之和等于目标值，并且组合中元素个数等于k,说明了找到了一种可行解
            if (curSum == target && solution.size() == k)
            {
                solutions.push_back(solution);
            }
            //回退
            solution.pop_back();
            return;
        }

        //从下一个元素开始进行深度搜索
        for (int idx = start + 1; idx <= 9; ++idx)
        {
            dfs(target, curSum, idx, k);
        }

        //回退
        solution.pop_back();
    }
};
```



## 13.活字印刷

<a href="https://leetcode-cn.com/problems/letter-tile-possibilities/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225200514846.png" alt="image-20211225200514846" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    int numTilePossibilities(string tiles) {
        unordered_set<string> bank;     //set辅助去重
        vector<bool> visited(tiles.size(), false);
        
        dfs(tiles, "", bank, visited);
        
        return bank.size();
    }
private:
    void dfs(const string& tiles, string curStr,
        unordered_set<string>& bank, vector<bool>& visited)
    {
        //这里在进入if判断之后不能立即退出，否则不能找到所有解
        if(!curStr.empty())
        {
            if(!bank.count(curStr))
            {
                bank.insert(curStr);
            }
        }

        for(int i = 0; i < tiles.size(); ++i)
        {
            if(!visited[i])
            {
                visited[i] = true;
                dfs(tiles, curStr + tiles[i], bank, visited);
                visited[i] = false;
            }
        }
    }
};
```

## 14.N皇后问题

<a href="https://leetcode-cn.com/problems/n-queens/">Link</a>

题目介绍：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225200648650.png" alt="image-20211225200648650" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<pair<int, int>>> solutions;
        vector<pair<int, int>> solution;

        dfs(solutions, solution, n, 0);
        
        return transferFromPosToStr(solutions, n);
    }
    
private:
    //深度优先计算出所有可行的方法
    void dfs(vector<vector<pair<int, int>>>& solutions, 
        vector<pair<int, int>>& solution, int n, int curRow)
    {
        //递归出口
        if(curRow == n)
        {
            solutions.push_back(solution);
            return;
        }

        for(int i = 0; i < n; ++i)
        {
            //判断位置是否可行，可行就将其放入本轮结果中
            if(IsValidPos(curRow, i, solution))
            {
                solution.push_back(make_pair(curRow,i));
                //为其他皇后找位置
                dfs(solutions, solution, n, curRow + 1);
                //回退
                solution.pop_back();
            }
        }
    }

    //将可行的位置信息转换为字符形式
    vector<vector<string>> transferFromPosToStr(vector<vector<pair<int, int>>>& solutions, int n)
    {
        vector<vector<string>> allRes;

        for(auto& method : solutions)
        {
            vector<string> res(n, string(n, '.'));
            for(auto& pos : method)
            {
                res[pos.first][pos.second] = 'Q';
            }
            allRes.push_back(res);
        } 
        return allRes;     
    }

    //判断当前位置是否可行
    //row和solution中的元素肯定不在同一行
   bool IsValidPos(int row, int col, vector<pair<int, int>>& solution)
   {
       for(auto& pos : solution)
       {
           //不能在同一行、同一列、同一条斜线上(在同一条斜线上斜率为1或者-1)
           if(pos.second == col || row + col == pos.first + pos.second
                || row - col == pos.first - pos.second)
            {
                return false;
            }
       }
       return true;
   }
};
```

## 15.分割回文串

<a href="https://leetcode-cn.com/problems/palindrome-partitioning/">Link</a>

题目介绍：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211229172730824.png" alt="image-20211229172730824" style="zoom:50%;" />

代码：

```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {
        int len = s.size();
        IsPalion.resize(len, vector<bool>(len, true));

        //预处理
        //从后往前进行初始化
        for(int start = len - 2; start >= 0; --start)
        {
            for(int end = start + 1; end < len; ++end)
            {
                IsPalion[start][end] = (s[start] == s[end]) && IsPalion[start + 1][end - 1];
            }
        }

        //深度优先搜索
        dfs(s, len, 0);

        return solutions;
    }
private:
    vector<vector<string>> solutions;      //结果集
    vector<string> solution;               //一条结果
    vector<vector<bool>> IsPalion;      //IsPalin[begin][end]:[begin, end]子串是否回文

    void dfs(const string& s, int len, int start)
    {
        //递归出口
        if(start == len)
        {
            solutions.push_back(solution);
            return;
        }

        //枚举start位置和之后的所有位置
        for(int end = start; end < len; ++end)
        {
            //区间[start, end]是回文子串，继续搜索end之后的位置
            if(IsPalion[start][end])
            {
                solution.push_back(s.substr(start, end - start  + 1));
                dfs(s, len, end + 1);
                solution.pop_back();
            }
        }
    }
};
```

## 16.复原IP地址

<a href="https://leetcode-cn.com/problems/restore-ip-addresses/">Link</a>

题目介绍：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211229185604207.png" alt="image-20211229185604207" style="zoom:50%;" />

代码：

```cpp
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        dfs(s, 0);
        return Convert();
    }
private:
    vector<vector<string>> solutions;       //结果集
    vector<string> solution;                //一条结果

    //深度优先搜索得到可行的IP地址
    void dfs(const string& s, int start)
    {
        //递归出口
        if (start >= s.size() || solution.size() == 4)
        {
            if (start == s.size() && solution.size() == 4)
            {
                solutions.push_back(solution);
            }
            return;
        }

        //每次枚举1、2、3位数字字符作为一个整数，并搜索下一个整数
        for (int i = 0; i < 3; ++i)
        {
            string str = s.substr(start, i + 1);
            int num = stoi(str);
            if (num >= 0 && num <= 255)
            {
                if(str.size() > 1 && str[0] == '0')
                {
                    continue;
                }
                solution.push_back(str);
                dfs(s, start + i + 1);
                solution.pop_back();
            }
        }
    }

    //将二维数组形式的结果集转换为一维数组形式
    vector<string> Convert()
    {
        vector<string> res;
        string curStr;

        for (const auto& solution : solutions)
        {
            curStr.clear();
            for (int i = 0; i < 3; ++i)
            {
                curStr += solution[i] + ".";
            }
            curStr += solution[3];
            res.push_back(curStr);
        }

        return res;
    }
};
```

## 17.子集

<a href="https://leetcode-cn.com/problems/subsets/">link</a>

题目介绍：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211229194027723.png" alt="image-20211229194027723" style="zoom:50%;" />

代码：

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        dfs(nums, 0);

        return solutions;
    }

private:
    vector<vector<int>> solutions;
    vector<int> solution;
    void dfs(const vector<int>& nums, int idx)
    {
        if(idx == nums.size())
        {
            solutions.push_back(solution);
            return;
        }

        //可以选择添加当前元素，也可以选择不添加当前元素

        //1.不放置当前元素
        dfs(nums, idx + 1);

        //2.放置当前元素
        solution.push_back(nums[idx]);
        //处理下一个元素
        dfs(nums, idx + 1);
        //回退
        solution.pop_back();
    }
};
```

## 18.子集II

<a href="https://leetcode-cn.com/problems/subsets-ii/">Link</a>

题目介绍：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211230154314600.png" alt="image-20211230154314600" style="zoom:50%;" />

代码：

```cpp
class Solution {
public:
    vector<int> t;
    vector<vector<int>> ans;

    //choosePre参数表示当前元素的前一个元素是否被选入子集中
    void dfs(bool choosePre, int cur, vector<int> &nums) {
        if (cur == nums.size()) {
            ans.push_back(t);
            return;
        }
        dfs(false, cur + 1, nums);

        //这道题最大的难点在于去重
        /*
            对于当前选择的数 cur,它的前一个数prev和它的值相等，并且没有选择prev，
            此时如果选择了cur,就会造成重复
            原因在于在其他的执行流中，
            前一项prev如果被选中，而当前项cur没有被选中，会产生相同的结果
        */
        if (!choosePre && cur > 0 && nums[cur - 1] == nums[cur]) {
            return;
        }
        t.push_back(nums[cur]);
        dfs(true, cur + 1, nums);
        t.pop_back();
    }

    vector<vector<int>> subsetsWithDup(vector<int> &nums) {
        sort(nums.begin(), nums.end());
        dfs(false, 0, nums);
        return ans;
    }
};
```



## 19.全排列

<a href="https://leetcode-cn.com/problems/permutations/">Link</a>

题目介绍：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211230155331014.png" alt="image-20211230155331014" style="zoom:50%;" />

代码：

```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        dfs(0, nums);

        return solutions;
    }
private:
    vector<vector<int>> solutions;

    void dfs(int start, vector<int>& nums)
    {
        if(start == nums.size())
        {
            solutions.push_back(nums);
            return;
        }

        for(int idx = start; idx < nums.size(); ++idx)
        {
            swap(nums[start], nums[idx]);
            dfs(start + 1, nums);
            swap(nums[start], nums[idx]);
        }
    }
};
```

## 20.全排列II

<a href="https://leetcode-cn.com/problems/permutations-ii/submissions/">Link</a>

题目介绍：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20220105073132750.png" alt="image-20220105073132750" style="zoom:50%;" />

解题思路：

这道题和全排列I最大的不同在于需要进行去重，去重就要保证重复区间按照从左到右的顺序进行访问，因此定义一个规则，保证每次访问的是重复区间从左到右第一个没有被访问的元素

代码：

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        int n = nums.size();
        vector<bool> visited(n, false);

        sort(nums.begin(), nums.end());
        dfs(0, nums, visited);
        return solutions;
    }
private:
    vector<vector<int>> solutions;
    vector<int> solution;

    void dfs(int cur, const vector<int>& nums, vector<bool>& visited)
    {
        if(cur == nums.size())
        {
            solutions.push_back(solution);
            return;
        }

        for(int i = 0; i < nums.size(); ++i)
        {
            //保证重复元素区间按照从左到右选择第一个没有被使用的元素
            if(visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]))
            {
                continue;
            }

            solution.push_back(nums[i]);
            visited[i] = true;
            dfs(cur + 1, nums, visited);
            solution.pop_back();
            visited[i] = false;
        }
    }
};
```

## 21.递增子序列

<a href="https://leetcode-cn.com/problems/increasing-subsequences/">Link</a>

题目简介：

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20220105092526426.png" alt="image-20220105092526426" style="zoom:50%;" />

解题思路：

采用深度优先进行搜索，从0号下标开始进行搜索，

对于到达的每个位置的元素，有两种选择，放入当前结果和不放入当前结果；

放入当前结果的前提条件是当前元素的值大于等于前一项元素的值，只有这样才能满足递增子序列的条件；

当前元素可以选择不放入当前结果，但是如果当前元素等于前一项元素，那么此时就必须放入当前元素,不能选择不放入当前元素，

如果当前元素不放入结果中就会产生重复的结果，因为在另一条执行流中，没有放置前一个元素，但是放置了当前元素，两条执行流会产生相同的结果，因此需要舍弃一条执行流，选择舍弃放置前一个元素但是不放置当前元素的执行流；

最后的递归出口，应该设置为走到了数组末尾，并且此时结果中至少有两个元素；

**下面是关于去重的执行流舍弃示意图:**

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20220105093724822.png" alt="image-20220105093724822" style="zoom:50%;" />

代码：

```cpp
class Solution {
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        dfs(0, INT_MIN, nums);
        return solutions;
    }
private:
    vector<int> solution;
    vector<vector<int>> solutions;

    void dfs(int cur, int lastVal, const vector<int>& nums)
    {
        if(cur == nums.size())
        {
            if(solution.size() >= 2)
            {
                solutions.push_back(solution);
            }
            return;
        }

        //放置当前元素
        if(nums[cur] >= lastVal)
        {
            //当前元素大于等于前一项元素的值才能放置当前元素
            solution.push_back(nums[cur]);      
            dfs(cur + 1, nums[cur], nums);
            solution.pop_back();
        }
        
        //不放置当前元素
        if(nums[cur] != lastVal)
        {
            //当前元素和前一项元素不相等时，不能放置当前元素
            //因为存在另一条执行流，在那条执行流中前一项元素没有被放置，而当前元素被放置
            //如果前一项元素被放置而当前元素没有被放置，则会产生重复的结果
            dfs(cur + 1, lastVal, nums);
        }
    }
};
```

## 22.重新安排行程

<a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">Link</a>

题目介绍：
<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20220105110637846.png" alt="image-20220105110637846" style="zoom:50%;" />

代码：

```cpp
class Solution {
    //ticketNum:票的个数
    //result:结果集
    bool backtracking(int ticketNum, vector<string>& result) {
        /*
            遇到的机场个数，如果达到了（航班数量+1），那么我们就找到了一个行程，把所有航班串在一起了
        */
        if (result.size() == ticketNum + 1) {
            return true;
        }
        //从上一次到达的位置出发
        for (pair<const string, int>& target : targets[result[result.size() - 1]]) {
            if (target.second > 0 ) { // 记录到达机场是否飞过了
                result.push_back(target.first);
                target.second--;
                if (backtracking(ticketNum, result)) 
                    return true;
                result.pop_back();
                target.second++;
            }
        }
        return false;
    }
public:
    /*
        题目要求：
        假定所有机票至少存在一种合理的行程，
        且所有的机票必须都用一次且只能用一次
    */
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        targets.clear();
        vector<string> result;  //结果集
        for (const vector<string>& vec : tickets) {
            targets[vec[0]][vec[1]]++; // 记录映射关系
        }
        result.push_back("JFK"); // 起始机场
        backtracking(tickets.size(), result);
        return result;
    }
private:
    // unordered_map<出发机场, map<到达机场, 航班次数>> targets
    unordered_map<string, map<string, int>> targets;
};
```

另一份注释过的代码：

```cpp
class Solution {
public:
	vector<string> findItinerary(vector<vector<string>>& tickets) {
		ticketMp.clear();
		//1.预处理
		for (auto& ticket : tickets)
		{
			++(ticketMp[ticket[0]][ticket[1]]);
		}

		vector<string> routes;
		routes.push_back("JFK");    //将起点加入路径

		//2.进行深度优先搜索
		IsArrived(tickets.size(), routes);

		return routes;
	}
private:
	//key为机票的起始位置
	//value表示这张机票能到达的位置集合
	//value采用map的原因是map的迭代器正向遍历按照key值从小到大进行
	unordered_map<string, map<string, int>> ticketMp;

	bool IsArrived(int tickNums, vector<string>& routes)
	{
		//递归出口
		//途经的机场数等于票数+1，说明这些票都使用过了
		//可以将途径的路径看作一个单链表，票对应的起始位置和结束位置对应链表的节点
		if (routes.size() == tickNums + 1)
		{
			return true;
		}

		//从上次到达的终点出发
		for (auto& des : ticketMp[routes[routes.size() - 1]])
		{
				if (des.second > 0)
				{
					routes.push_back(des.first);
					--des.second;
					
					//当前执行流找到了一条可行路径，也就是把所有的票都使用了
					//那么这条最早找到的路径就是最小路径
					if (IsArrived(tickNums, routes))
					{
						return true;
					}

					//回退
					routes.pop_back();
					++des.second;
				}
		}

		//当前票使用完了，但是没有找到可行路径
		return false;
	}
};
```



# 二.广度优先搜索

​		广度优先搜索的策略是一次处理一批

**bfs模型**

```cpp
1. 队列初始化
2.whlie(队列不为空) 
{ 
    int sz = q.size();
    //一次处理一批
    while(sz--)
    {
        通过队头元素带出下一步的所有可能，并且依次入队
        { 
            判断当前情况是否达成目标,按照目标要求处理逻辑
        } 
    }
}
```

## 1.迷宫问题

问题描述:

​	有一张地图，0表示没有障碍物，1表示有障碍物，给你一幅地图、一个起始位置和一个目标位置，请判断是否能够从起始位置出发到达目标位置，可以的话将走过的路径用8进行标记

查找路径思路：
1. 将起点位置存入队列中；
2. 每次访问队头元素，让队头元素出队，标记队头元素已经访问过，并在地图中将队头位置标记为8；如果队头元素就是目标位置，查找结束返回；如果不是，同时进行上下左右四个方向的移动，如果移动到的新位置是可通的并且没有被访问，将这个新位置入队；
3. 重复上一步直到队列为空，如果队列为空，说明到达不了目标位置；

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

//位置
struct PosType
{
	int _x, _y;

	PosType()
		:_x(0)
		,_y(0)
	{}

	PosType(int x, int y)
		:_x(x)
		, _y(y)
	{}
};

//判断两个位置是否相同,不能加const修饰，此处没有this指针
bool operator==(const PosType& pos1, const PosType& pos2)	//const
{
	return pos1._x == pos2._x && pos1._y == pos2._y;
}

//判断两个位置是否不同,不能加const修饰，此处没有this指针
bool operator!=(const PosType& pos1, const PosType& pos2)	//const
{
	return pos1._x != pos2._x || pos1._y != pos2._y;
}

//迷宫输入
void InitMaze(vector<vector<int>>& map)
{
	cout << "迷宫地图初始化开始，0表示没有障碍物，1表示有障碍物" << endl;
	int row = map.size(), col = map[0].size();
	for (int i = 0; i < row; ++i)
	{
		for (int j = 0; j < col; ++j)
		{
			cin >> map[i][j];
		}
	}
	cout << "初始化完毕!" << endl;
}

//打印地图
void PrintMap(const vector<vector<int>>& map)
{
	int row = map.size(), col = map[0].size();
	for (int i = 0; i < row; ++i)
	{
		for (int j = 0; j < col; ++j)
		{
			cout << map[i][j] << "\t";
		}
		cout << endl;
	}
	cout << endl;
}

//判断是否有从beginPos到endPos的路径,使用队列进行广度优先搜索
bool IsHasPath(vector<vector<int>>& map, PosType beginPos, PosType endPos)
{
	int rows = map.size(), cols = map[0].size();	//行数和列数

	//1.检查位置是否有效
	if (beginPos._x < 0 || beginPos._x >= rows
		|| beginPos._y < 0 || beginPos._y >= cols
		|| endPos._x < 0 || endPos._x >= rows
		|| endPos._y < 0 || endPos._y >= cols
		|| map[beginPos._x][beginPos._y] == 1 
		|| map[endPos._x][endPos._y] == 1)
	{
		return false;
	}

	int nextStep[4][2] = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };	//四个移动方向
	vector<vector<bool>> visited(rows, vector<bool>(cols, false));		//标记位置是否已经访问过
	
	queue<PosType> q;
	q.push(beginPos);

	//进行广度优先搜索
	while (!q.empty())
	{
		PosType front = q.front();
		q.pop();
		visited[front._x][front._y] = true;
		map[front._x][front._y] = 8;
		
		if (front == endPos)
		{
			return true;
		}

		for (int i = 0; i < 4; ++i)
		{
			int curX = front._x + nextStep[i][0];
			int curY = front._y + nextStep[i][1];
			if (curX < 0 || curX >= rows || curY < 0 || curY >= cols)
			{
				continue;
			}
			if (!visited[curX][curY] && map[curX][curY] == 0)
			{
				q.push(PosType(curX, curY));
			}
		}
	}
	//遍历结束，没有找到目标位置
	return false;
}


//开始游戏
void GameStart(vector<vector<int>>& map)
{
	int row = map.size(), col = map[0].size();

	PosType beginPos, endPos;		//起始位置，目标位置
	cout << "请输入起始位置下标: ";
	cin >> beginPos._x >> beginPos._y;
	cout << "请输入目标位置下标: ";
	cin >> endPos._x >> endPos._y;

	//判断是否可以到达目标位置
	bool ret = IsHasPath(map, beginPos, endPos);
	if (ret)
	{
		//可以到达目标位置，打印路径
		cout << "可以到达目标位置,路径如下,走过的位置用8表示" << endl;
		PrintMap(map);
	}
	else
	{
		//不能到达目标位置
		cout << "这是一个无法到达的位置" << endl;
	}
}

int main()
{
	int row, col;
	cout << "请输入迷宫的行数和列数: ";
	cin >> row >> col;

	vector<vector<int>> matrix(row, vector<int>(col));

	cout << "请初始化迷宫" << endl;
	InitMaze(matrix);

	//打印迷宫
	PrintMap(matrix);

	//开始游戏
	GameStart(matrix);

	return 0;
}
```

## 2.N叉树的层序遍历

<a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225192411205.png" alt="image-20211225192411205" style="zoom:70%;" />

解题思路：

1. 将根节点入队；

​	2. 获取队列的元素个数sz, 处理队列中的sz个元素:

​		将每个元素的所有孩子入队，并将此时的队头元素插入本层遍历的结果，最后将本层遍历结果插入结果集中；

​	3. 重复上一步直到队列为空

代码:

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> solutions;
        vector<int> solution;

        queue<Node*> q;
        //根节点入队
        if(root)
        {
            q.push(root);
        }
        while(!q.empty())
        {
            int sz = q.size();
            solution.clear();
            //一次处理一批
            while(sz--)
            {
                Node* front = q.front();
                q.pop();	
                //将队头元素插入本轮结果中
                solution.push_back(front->val);
				//将队头元素的所有孩子入队，为下一轮处理做准备
                for(auto& node : front->children)
                {
                    q.push(node);
                }
            }
            //将本层遍历的结果插入结果集中
            solutions.push_back(solution);
        }

        return solutions;
    }
};
```

## 3.腐烂的橘子

<a href="https://leetcode-cn.com/problems/rotting-oranges/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225193144940.png" alt="image-20211225193144940" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int rows = grid.size(), cols = grid[0].size();
        queue<pair<int, int>> q;
        //1.将腐烂的橘子入队
        for(int i = 0; i < rows; ++i)
        {
            for(int j = 0; j < cols; ++j)
            {
                if(grid[i][j] == 2)
                {
                    q.push(make_pair(i, j));
                }
            }
        }

        const int nextStep[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};
        int times = 0;      //转换时间
        //2.从腐烂的橘子位置出发，每次转换一批
        while(!q.empty())
        {
            int sz = q.size();
            bool IsConverted = false;
            while(sz--)
            {
                pair<int, int> pos = q.front();
                q.pop();

                for(int i = 0; i < 4; ++i)
                {
                    int curX = pos.first + nextStep[i][0]; 
                    int curY = pos.second + nextStep[i][1];
                    if(curX < 0 || curX >= rows || curY < 0 || curY >= cols)
                    {
                        continue;
                    }
                    if(grid[curX][curY] == 1)
                    {
                        grid[curX][curY] = 2;
                        IsConverted = true;
                        q.push(make_pair(curX, curY));
                    }
                }
            }
            //这一轮发生了转换，就更新转换的时间
            if(IsConverted)
            {
                ++times;
            }
        }

        //3.检查是否还有新鲜的橘子
        for(int i = 0; i < rows; ++i)
        {
            for(int j = 0; j < cols; ++j)
            {
                if(grid[i][j] == 1)
                {
                    return -1;
                }
            }
        }

        return times;
    }
};
```

**!!!!!!!!!!!!!!!**

**只有本轮腐烂了新鲜的橘子，才会让转换时间+1**

## 4.单词接龙

<a href="https://leetcode-cn.com/problems/word-ladder/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225193435730.png" alt="image-20211225193435730" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> s(wordList.begin(), wordList.end());
        if(s.count(endWord) == 0)
        {
            return 0;
        }

        queue<string> q;
        unordered_set<string> visited;
        q.push(beginWord);
        visited.insert(beginWord);

        int steps = 1;		//根据题意，起始时间为1
        while(!q.empty())
        {
            int sz = q.size();
            bool IsCoverted = false;        //是否转换标志位
            //一次转换一批
            while(sz--)
            {
                string frontStr = q.front();
                q.pop();
                //找到了结束单词
                if(frontStr == endWord)
                {
                    return steps;
                }
                
                //对队头的每个单词的每一位进行转换
                for(int i = 0; i < frontStr.size(); ++i)
                {
                    string copy(frontStr);
                    for(char ch = 'a'; ch <= 'z'; ++ch)
                    {
                        copy[i] = ch;

                        //新单词在词典中，但是之前没有出现过，将其入队，进行下一轮转换
                        if(s.count(copy) && visited.count(copy) == 0)
                        {
                            q.push(copy);
                            visited.insert(copy);
                            IsCoverted = true;
                        }
                    }
                }
            }
            //本轮发生了转换，那么转换序列中的单词数+1
            if(IsCoverted)
            {
                ++steps;
            }
        }

        //没找到
        return 0;
    }
};
```



## 5.最小基因变化

<a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225193709506.png" alt="image-20211225193709506" style="zoom:50%;" />

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225193732434.png" alt="image-20211225193732434" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    int minMutation(string start, string end, vector<string>& bank) {
        //使用哈希表作为词典
        unordered_set<string> bank_set(bank.begin(), bank.end());

        //结束单词不在词典，转换失败
        if(bank_set.count(end) == 0)
        {
            return -1;
        }

        int steps = 0;                  //转换的步数
        unordered_set<string> visited;  //标记哪些基因序列已经使用
        queue<string> q;
        const char gene[4] = {'A', 'C', 'G', 'T'};       //四种基因转换选择
        q.push(start);
        visited.insert(start);

        while(!q.empty())
        {
            bool IsConverted = false;       //本轮是否有基因序列转换成功
            int sz = q.size();
            //一次转换一批
            while(sz--)
            {
                string frontStr = q.front();
                q.pop();

                if(frontStr == end)
                {
                    return steps;
                }

                //对基因序列的每个基因进行转换
                for(int i = 0; i < frontStr.size(); ++i)
                {
                    string copy(frontStr);
                    for(int j = 0; j < 4; ++j)
                    {
                        copy[i] = gene[j];

                        //词典中基因转换序列存在，并且没有被使用过，将其入队，进行下一轮转换
                        if(bank_set.count(copy) && visited.count(copy) == 0)
                        {
                            q.push(copy);
                            visited.insert(copy);
                            IsConverted = true;
                        }
                    }
                }
            }
            if(IsConverted)
            {
                ++steps;
            }
        }

        //无法实现目标变化，返回-1
        return -1;
    }
};
```

## 6.打开转盘锁

<a href="https://leetcode-cn.com/problems/open-the-lock/">Link</a>

题目介绍:

<img src="C:\Users\cxp\AppData\Roaming\Typora\typora-user-images\image-20211225193844699.png" alt="image-20211225193844699" style="zoom:50%;" />

代码:

```cpp
class Solution {
public:
    int openLock(vector<string>& deadends, string target) {
        //组织一个词典，方便高效查找
        unordered_set<string> dead_set(deadends.begin(), deadends.end());
        //起始数字或者结束数字有一者在死亡数组中，无法转换
        if(dead_set.count("0000") || dead_set.count(target))
        {
            return -1;
        }

        int steps = 0;
        queue<string> q;
        unordered_set<string> visited;
        q.push("0000");
        visited.insert("0000");

        while(!q.empty())
        {
            int sz = q.size();
            bool IsConverted = false;       //标记本轮是否旋转到了一个非死亡数字

            while(sz--)
            {
                string frontStr = q.front();
                q.pop();

                if(frontStr == target)
                {
                    return steps;
                }

                for(int i = 0; i < frontStr.size(); ++i)
                {
                    string leftRotateRes(frontStr);
                    string rightRotateRes(frontStr);
                    leftRotateRes[i] = leftRotateRes[i] == '0' ? '9' :leftRotateRes[i] - 1;             
                    rightRotateRes[i] = rightRotateRes[i] == '9' ? '0' :rightRotateRes[i] + 1;        
                    
                    if(dead_set.count(leftRotateRes) == 0 && visited.count(leftRotateRes) == 0)
                    {
                        q.push(leftRotateRes);
                        visited.insert(leftRotateRes);
                        IsConverted = true;
                    }     
                    if(dead_set.count(rightRotateRes) == 0 && visited.count(rightRotateRes) == 0)
                    {
                        q.push(rightRotateRes);
                        visited.insert(rightRotateRes);
                        IsConverted = true;
                    }    
                }
            }
            if(IsConverted)
            {
                ++steps;
            }
        }

        //无法解锁
        return -1;
    }
};
```

