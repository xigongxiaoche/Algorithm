@[TOC](栈)

# 一.经典例题

## 1.二叉树转换为单链表

<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/submissions/">Link</a>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
//前序遍历和展开同步进行
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* prev = nullptr;       //前序遍历的前一个节点
        stack<TreeNode*> st;
        if(root)
        {
            st.push(root);
        }
        while(!st.empty())
        {
            TreeNode* top = st.top();
            st.pop();
            //将右孩子保存到栈中,因为接下来会对节点指向进行修改
            if(top->right)
            {
                st.push(top->right);
            }
            //左孩子后入栈,保证左孩子先被访问
            if(top->left)
            {
                st.push(top->left);
            }
            //更新节点指向
            top->left = nullptr;
            if(prev)
            {
                prev->right = top;
            }
            //更新前序遍历的前一个节点
            prev= top;
        }
        //让尾部节点的下一个位置指向空
        if(prev)
        {
            prev->right = nullptr;
        }
    }
};
```

## 2.最小栈

<a href="https://leetcode-cn.com/problems/min-stack/">Link</a>

### 解法1：让最小栈和数据栈元素个数保持相等

```cpp
class MinStack {
private:
    stack<int> _data;       //数据栈
    stack<int> _min;        //最小栈
public:
    MinStack() {

    }
    
    void push(int val) {
        _data.push(val);
        //当插入的元素小于最小栈的栈顶元素或者最小栈为空，将元素插入最小栈
        if(_min.empty() || val < _min.top())
        {
            _min.push(val);
        }
        //为了保持最小栈和数据栈元素个数相同，给最小栈继续插入最小栈栈顶元素
        else
        {
            _min.push(_min.top());
        }
    }
    
    void pop() {
        _data.pop();
        _min.pop();
    }
    
    int top() {
        return _data.top();
    }
    
    int getMin() {
        return _min.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

### 解法2：进行条件判断

```cpp
class MinStack {
private:
    stack<int> _data;       //数据栈
    stack<int> _min;        //最小栈
public:
    MinStack() {

    }
    
    void push(int val) {
        _data.push(val);
        //当插入的元素小于等于最小栈的栈顶元素或者最小栈为空，将元素插入最小栈
        //刚才在这里浪费的时间是因为如果插入的数据等于最小栈的栈顶元素，继续插入这个数据
        //因为这个数据可能之前就已经在栈中了
        if(_min.empty() || val <= _min.top())
        {
            _min.push(val);
        }
    }
    
    void pop() {
        if(_data.top() == _min.top())
        {
            _min.pop();
        }
        _data.pop();
    }
    
    int top() {
        return _data.top();
    }
    
    int getMin() {
        return _min.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

## 3.回文链表

<a href="https://leetcode-cn.com/problems/palindrome-linked-list/">Link</a>

通过栈进行辅助

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* curNode = head;
        stack<ListNode*> st;
        while(curNode)
        {
            st.push(curNode);
            curNode = curNode->next;
        }
        curNode = head;
        while(!st.empty())
        {
            if(st.top()->val != curNode->val)
            {
                return false;
            }
            st.pop();
            curNode = curNode->next;
        }
        return true;
    }
};
```

## 4.每日温度

<a href="https://leetcode-cn.com/problems/daily-temperatures/">Link</a>



### 方法1：单调栈

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int len = temperatures.size();
        vector<int> ans(len, 0);        //温度回升天数数组
        stack<int> st;
        for(int i = 0; i < len; ++i)
        {
            //栈不为空，并且当前温度大于栈顶下标对应的温度，说明现在遇到了第一个温度比栈顶下标对应温度高的一天，更新栈顶下标对应的温度回升天数
            while(!st.empty() && temperatures[i] > temperatures[st.top()])
            {
                int temp_idx = st.top();
                st.pop();
                ans[temp_idx] = i - temp_idx;
            }
            st.push(i);
        }
        return ans;
    }
};
```

### 方法2：有脑的暴力解法

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int len = temperatures.size();
        vector<int> timeWaiting(len, 0);
        vector<int> allTemp(101, INT_MAX);      //从0度到100度，每个温度出现的最小下标
        //从后往前进行更新
        for(int i = len - 1; i >= 0; --i)
        {
            int warmerIdx = INT_MAX;
            //从当前对应的温度开始向后查找第一个出现的位置不为INT_MAX的值
            for(int t = temperatures[i] + 1; t <= 100; ++t)
            {
                warmerIdx = min(warmerIdx, allTemp[t]);
            }
            //如果后面出现了比当前温度更高的温度，更新结果集
            if(warmerIdx != INT_MAX)
            {
                timeWaiting[i] = warmerIdx - i;
            }
            //更新每个温度最早出现的下标
            allTemp[temperatures[i]] = i;
        }
        return timeWaiting;
    }
};
```

## 5.最短连续无序子数组

<a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">Link</a>


### 方法1：单调栈
```cpp
class Solution {
public:
  int findUnsortedSubarray(vector<int>& nums) {
    stack<int> s;
    int n = nums.size();
    int left = n, right = -1;
    for (int i = 0; i < n; ++i) 
    {
      // 遇到一个比top小的元素需要排序到前面
      if (!s.empty() && nums[s.top()] > nums[i])
      {
        int maxVal = s.top();
        right = max(right, i); // 更新右边界
        while (!s.empty() && nums[s.top()] > nums[i])
        {
          left = min(left, s.top()); // 更新最远的左边界
          s.pop();
        }
        // 最大代表元重新入栈保证后续元素一定是与前方所有元素最大值比较
        // 一旦大于最大值就无须排序
        s.push(maxVal);
      }
      //栈为空或者当前元素大于等于栈顶元素，将其下标入栈
      else
      {
        s.push(i);
      }
    }
    return left < right ? right - left + 1 : 0;
  }
};
```

### 方法2：双指针

```cpp
class Solution {
public:
   int findUnsortedSubarray(vector<int>& nums) {
	//nums可以分为左中右三个区间
	//左侧区间的元素全部小于中间区间的元素，右侧区间的元素全部大于中间区间的元素
	int n = nums.size();
	int maxn = INT_MIN, right = -1;	//maxn是左侧区间的最大值，right是中间区间的结束位置
	int minn = INT_MAX, left = -1;	//minn是右侧区间的最小值，left是中间区间的起始位置
	for (int i = 0; i < n; i++) {
		//maxn和当前位置的元素进行比较
		if (maxn > nums[i]) {
			right = i;
		}
		else {
			maxn = nums[i];
		}
		//minn和与当前下标互补位置的元素进行比较
		if (minn < nums[n - i - 1]) {
			left = n - i - 1;
		}
		else {
			minn = nums[n - i - 1];
		}
	}
	return right == -1 ? 0 : right - left + 1;
}
};
```

### 方法3：暴力解法(排序+遍历)

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        vector<int> copy(nums);
        sort(copy.begin(), copy.end());
        int len = nums.size();
        int left = -1, right = -2;      //目标区间的左孩子大于右孩子是为了处理有序的情况
        for(int i = 0; i < len; ++i)
        {
            if(nums[i] != copy[i])
            {
                left = i;
                break;
            }
        }
        for(int i = len - 1; i >= 0; --i)
        {
            if(nums[i] != copy[i])
            {
                right = i;
                break;
            }
        }
        return right - left + 1;
    }
};
```

## 6.字符串解码

<a href="https://leetcode-cn.com/problems/decode-string/">Link</a>


### 解法1：用顺序表模拟栈

```cpp
class Solution {
public:
    string decodeString(string s) {
        vector<string> stk;         //通过顺序表模拟一个栈,尾部就是栈顶
        int idx = 0, len = s.size();
        while(idx < len)
        {
            //遇见数字字符，将一个数字入栈
            if(isdigit(s[idx]))
            {
                stk.push_back(getDigit(s, idx));
            }
            //遇见字母字符或者[将其入栈
            else if(isalpha(s[idx]) || s[idx] == '[')
            {
                //在这里我直接插入字符，类型不匹配
                stk.push_back(s.substr(idx, 1));
                ++idx;
            }
            //遇见],开始出栈
            else
            {
                //让当前下标后移
                ++idx;
                //sub用于暂存出栈的字符串
                vector<string> sub;
                //将左括号之后的所有字符出栈
                while(!stk.empty() && stk.back() != "[")
                {
                    sub.push_back(stk.back());
                    stk.pop_back();
                }
                //左括号出栈
                stk.pop_back();

                //逆置出栈后的字符串数组，因为字符串数组的顺序和实际的顺序相反
                reverse(sub.begin(), sub.end());
    
                //将需要重复的字符串进行拼接
                int repeatTime = stoi(stk.back());
                //数字出栈
                stk.pop_back();
                string total, part = getCombingString(sub);
                while(repeatTime--)
                {
                    total += part;
                }
                cout << total << endl;
                //将组合后的字符串压栈
                stk.push_back(total);
            }
        }
        //返回栈中字符串的组合
        return getCombingString(stk);
    }
private:
    //返回从当前位置出发的一个数字,遇见非数字字符截至
    //idx应该设置为引用,这样可以保证遍历位置的准确性
    string getDigit(const string& s, int& idx)
    {
        string ans;
        while(isdigit(s[idx]))
        {
            ans += s[idx];
            ++idx;
        }
        return ans;
    }
    //将vector中的string从头到尾进行组合并返回
    string getCombingString(const vector<string>& arr)
    {
        string ans;
        for(const auto& str : arr)
        {
            ans += str;
        }
        return ans;
    }
};
```

### 解法2：递归

```cpp
class Solution {
public:
	string decodeString(string s) {
		src = s;
		ptr = 0;
		return getString();
	}
private:
	string src;
	size_t ptr;
	string getString()
	{
		//递归出口
		if (ptr == src.size() || src[ptr] == ']')
		{
			//字符串遍历结束或者到达一个右括号的位置，返回一个空字符串
			return "";
		}

		string res;

		//字母字符直接返回对应的字符串
		if (isalpha(src[ptr]))
		{
            //在这里我浪费了时间，对于递归没有理解透彻
            /*
                while (ptr < src.size() && isalpha(src[ptr]))
                {
                    res += src[ptr++];
                }
                return res;
            */
			res = src[ptr++];
		}
		//数字字符开始进行组合
		else if (isdigit(src[ptr]))
		{
			int repeatTime = stoi(getDigit());
			//跳过左括号
			++ptr;
			//获取右括号之前的字符串
			string part = getString();
			//进行组合
			while (repeatTime--)
			{
				res += part;
			}
			//跳过右括号
			++ptr;
		}
        //处理下一步
		return res + getString();
	}

	//获取一个数字，前提是当前字符是数字字符
	string getDigit()
	{
		string res;
		while (ptr < src.size() && isdigit(src[ptr]))
		{
			res += src[ptr++];
		}
		return res;
	}
};
```

## 7.柱状图中最大的矩形

<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">Link</a>
### 解法1：单调栈

```cpp
//单调栈，这种思路简直美如画
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        //left存储的是从当前位置向左出发第一个高度小于当前高度的柱子的下标
        //right存储的是从当前位置向右出发第一个高度小于当前高度的柱子的下标
        vector<int> left(n), right(n);      
        stack<int> st;      //通过单调栈来辅助

        //查找左边界
        for(int i = 0; i < n; ++i)
        {
            //出栈所有的大于等于当前柱子高度的下标
            while(!st.empty() && heights[st.top()] >= heights[i])
            {
                st.pop();
            }
            //如果此时栈为空，说明当前柱子的左边没有比它低的，左边界为-1
            //否则左边界为栈顶元素
            left[i] = st.empty() ? -1 : st.top();
            //将下标入栈
            st.push(i);
        }

        //清空栈
        while(!st.empty())
        {
            st.pop();
        }

        //查找右边界
        for(int i = n - 1; i >= 0; --i)
        {
            //出栈所有的大于等于当前柱子高度的下标
            while(!st.empty() && heights[st.top()] >= heights[i])
            {
                st.pop();
            }
            //如果此时栈为空，说明当前柱子的右边没有比它低的，右边界为n
            //否则右边界为栈顶元素
            right[i] = st.empty() ? n : st.top();
            //将下标入栈
            st.push(i);   
        }
        
        int maxArea = 0;
        //从每个柱子出发，以当前柱子的高度为基准值，向左右两边发散，计算对应的矩形的面积
        for(int i = 0; i < n; ++i)
        {
            //右边界-左边界-1就是宽度
            int area = (right[i] - left[i] - 1) * heights[i];
            if(area > maxArea)
            {
                maxArea = area;
            }
        }

        return maxArea;
    }
};
```

### 解法2：单调栈常数级别的优化

```cpp
//单调栈，这种思路简直美如画
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        //left存储的是从当前位置向左出发第一个高度小于当前高度的柱子的下标
        //right存储的是从当前位置向右出发第一个高度小于当前高度的柱子的下标
        vector<int> left(n), right(n, n);      
        stack<int> st;      //通过单调栈来辅助

        //查找左右边界
        for(int i = 0; i < n; ++i)
        {
            //出栈所有的大于等于当前柱子高度的下标
            while(!st.empty() && heights[st.top()] >= heights[i])
            {
                //栈顶元素对应的柱子的高度大于等于当前柱子的高度
                //说明当前柱子是栈顶元素对应的柱子的右边界
                right[st.top()] = i;
                st.pop();
            }
            //如果此时栈为空，说明当前柱子的左边没有比它低的，左边界为-1
            //否则左边界为栈顶元素
            left[i] = st.empty() ? -1 : st.top();
            //将下标入栈
            st.push(i);
        }
        
        int maxArea = 0;
        //从每个柱子出发，以当前柱子的高度为基准值，向左右两边发散，计算对应的矩形的面积
        for(int i = 0; i < n; ++i)
        {
            //右边界-左边界-1就是宽度
            int area = (right[i] - left[i] - 1) * heights[i];
            if(area > maxArea)
            {
                maxArea = area;
            }
        }

        return maxArea;
    }
};
```

## 8.最大矩形

<a href="https://leetcode-cn.com/problems/maximal-rectangle/">Link</a>
### 解法1：单调栈
```cpp
class Solution {
public:
    //强大的单调栈
    int maximalRectangle(vector<vector<char>>& matrix) {
        int row = matrix.size();
        //进行判空处理
        if(row == 0)
        {
            return 0;
        }
        int col = matrix[0].size();

        vector<vector<int>> left(row, vector<int>(col, 0));
        //找到以当前节点作为矩形右下角的左边连续的节点个数
        for(int i = 0; i < row; ++i)
        {
            for(int j = 0; j < col; ++j)
            {
                if(matrix[i][j] == '1')
                {
                    left[i][j] = j == 0 ? 1 : (left[i][j - 1] + 1);
                }
            }
        }

        int maxArea = 0, area = 0;
        //在每一列上计算柱形图中的最大矩形
        for(int curCol = 0; curCol < col; ++curCol)
        {
            vector<int> up(row), down(row, row);     //上、下边界
            stack<int> st;

            //计算上下边界
            for(int j = 0; j < row; ++j)
            {
                while(!st.empty() && left[st.top()][curCol] >= left[j][curCol])
                {
                    down[st.top()] = j;
                    st.pop();
                }
                up[j] = st.empty() ? -1 : st.top();
                st.push(j);
            }

            //根据上下边界计算面积
            for(int j = 0; j < row; ++j)
            {
                area = (down[j] - up[j] - 1) * left[j][curCol];
                if(area > maxArea)
                {
                    maxArea = area;
                }
            }
        }
        return maxArea;
    }
};
```

### 解法2：有脑暴力解法

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if(matrix.empty())
        {
            return 0;
        }
        int row = matrix.size(), col = matrix[0].size();
        vector<vector<int>> left(row, vector<int>(col, 0));     //以当前位置为矩形的右下角的左侧的连续的1的个数

        //求出以当前位置为矩形的右下角的左边的连续的1的个数
        for(int i = 0; i < row; ++i)
        {
            for(int j = 0; j < col; ++j)
            {
                if(matrix[i][j] == '1')
                {
                    left[i][j] = j == 0 ? 1 : left[i][j - 1] + 1;
                }
            }
        }

        int maxArea = 0, area = 0;
        //计算最大面积
        for(int i = 0; i < row; ++i)
        {
            for(int j = 0; j < col; ++j)
            {
                if(left[i][j] == 0)
                {
                    continue;
                }

                int width = left[i][j];
                area = width;
                //找以当前位置作为矩形的右下角对应的面积
                for(int k = i - 1; k >= 0; --k)
                {
                    width = min(width, left[k][j]);
                    area = max(area, width * (i - k + 1));
                }
                if(area > maxArea)
                {
                    maxArea = area;
                }
            }
        }

        return maxArea;
    }
};
```

## 9.接雨水

<a href="https://leetcode-cn.com/submissions/detail/238276760/">Link</a>
### 解法1：单调栈

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int len = height.size();
        if(len == 0)
        {
            return 0;
        }

        int rainSum = 0;    //雨水总数
        stack<int> st;      //存储下标，从栈底到栈顶下标对应的高度递减
        for(int i = 0; i < len; ++i)
        {
            //当栈顶元素对应的柱子的高度小于此时柱子的高度，就计算栈顶元素对应的柱子处的存水量
            while(!st.empty() && height[st.top()] < height[i])
            {
                int topIdx = st.top();
                st.pop();
                if(!st.empty())
                {
                    int leftIdx = st.top();
                    int width = i - leftIdx - 1;
                    //当前柱子最高存储的水量等于两个边界存储量的最小值-当前柱子的高度
                    int h = min(height[i], height[leftIdx]) - height[topIdx];
                    rainSum += width * h;
                }
            }
            st.push(i);
        }

        return rainSum;
    }
};
```

### 解法2：动态规划

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int len = height.size();
        if(len == 0)
        {
            return 0;
        }

        vector<int> left(len);  //每个节点左边的最大高度
        vector<int> right(len); //每个节点右边的最大高度

        //计算每个节点左右两边的最大高度
        left[0] = height[0];
        for(int i = 1; i < len; ++i)
        {
            left[i] = max(left[i - 1], height[i]);
        }
        right[len - 1] = height[len - 1];
        for(int i = len - 2; i >= 0; --i)
        {
            right[i] = max(right[i + 1], height[i]);
        }

        //计算接水量
        int rainSum = 0;
        for(int i = 0; i < len; ++i)
        {
            rainSum += min(left[i], right[i]) - height[i];
        }

        return rainSum;
    }
};
```

### 解法3：双指针

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int len = height.size();
        int left = 0, right = len - 1;
        int leftMax = 0, rightMax = 0;  //当前位置及其左边或右边的柱子的最大高度
        int rainSum = 0;
        while(left < right)
        {
            leftMax = max(height[left], leftMax);
            rightMax = max(height[right], rightMax);
            if(height[left] < height[right])
            {
                rainSum += leftMax - height[left];
                ++left;
            }
            else
            {
                rainSum += rightMax - height[right];
                --right;
            }
        }
        return rainSum;
    }
};
```

## 10.最长有效括号

<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">Link</a>
```cpp
/*
    具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：

    对于遇到的每个左括号 ，我们将它的下标放入栈中
    对于遇到的每个右括号 ，我们先弹出栈顶元素表示匹配了当前右括号：
    如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
    如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」
    我们从前往后遍历字符串并更新答案即可。

    需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1 的元素。
*/
class Solution {
public:
    int longestValidParentheses(string s) {
        int maxans = 0;
        stack<int> stk;
        stk.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                stk.push(i);
            } else {
                stk.pop();
                if (stk.empty()) {
                    stk.push(i);
                } else {
                    maxans = max(maxans, i - stk.top());
                }
            }
        }
        return maxans;
    }
};
```

## 11.简化路径
<a href="https://leetcode-cn.com/problems/simplify-path/submissions/">Link</a>
题目介绍：
![在这里插入图片描述](https://img-blog.csdnimg.cn/21a70bf04896457fb85780823ba2f475.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

```cpp
class Solution {
public:
    string simplifyPath(string path) {
        //1.从前往后遍历字符串将/之间的字符串保存到数组中
        vector<string> strArr;
        string curStr;
        for(int i = 0; i < path.size(); ++i)
        {
            if(path[i] == '/')
            {
                strArr.push_back(curStr);
                curStr.clear();
            }
            else
            {
                curStr += path[i];
            }
        }
        //处理最后没有处理的字符串
        if(!curStr.empty())
        {
            strArr.push_back(curStr);
        }

        //删除空字符串
        vector<string>::iterator it = strArr.begin();
        while(it != strArr.end())
        {
            if(*it == "")
            {
                it = strArr.erase(it);
            }
            else
            {
                ++it;
            }
        }

        //2.将得到的目录名压入栈中
        stack<string> st;
        for(const auto& curStr : strArr)
        {
            st.push(curStr);
        }

        vector<string> routeArr;    //最终路径数组
        int cntOfPP = 0;            //回退到上层目录的特殊字符串出现的次数
        //3.开始出栈，遇见有效路径存储起来，遇见..回退到上一级目录
        while(!st.empty())
        {
            string topStr = st.top();
            st.pop();

            if(topStr != ".." && topStr != ".")
            {
                //栈顶元素是有效路径，将其保存到最终路径中
                routeArr.push_back(topStr);
            }
            else if(topStr == "..")
            {
                ++cntOfPP;
            }

            //遇见了..就进行回退
            while(!st.empty() && st.top() != ".." && st.top() != "." && cntOfPP > 0)
            {
                st.pop();
                --cntOfPP;
            }
        }
        
        //处理回退到根目录的情况
        if(routeArr.empty())
        {
            return "/";
        }
        
        return ConvertFromArr(routeArr);
    }

private:
    //将保存目录的数组从尾到头进行组合成为一个完整的路径
    string ConvertFromArr(const vector<string>& arr)
    {
        string res("/");
        for(int i = arr.size() - 1; i > 0; --i)
        {
            res += arr[i];
            res += "/";
        }
        res += arr[0];

        return res;
    }
};
```

## 12.下一个更大元素I
<a href="https://leetcode-cn.com/problems/next-greater-element-i/">Link</a>
题目介绍：
![在这里插入图片描述](https://img-blog.csdnimg.cn/4a0687cabe47498b8217c85d73ecd888.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)
**代码：**

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        int len = nums2.size();
        unordered_map<int, int> mp_val_idx;     //key为元素的值，value是元素在nums2中右边的第一个大于它的值
        stack<int> st;          //使用单调栈

        //1.统计nums每个元素对应右边位置的下一个比它大的值的位置
        for(int i = len - 1; i >= 0; --i)
        {
            //右边的元素比栈顶元素小,让栈顶元素出栈
            while(!st.empty() && nums2[i] > nums2[st.top()])
            {
                st.pop();
            }

            //栈为空，说明右边没有更大的元素
            if(st.empty())
            {
                mp_val_idx[nums2[i]] = -1;
            }
            else
            {
                mp_val_idx[nums2[i]] = nums2[st.top()];
            }
            st.push(i);
        }

        //2.遍历nums1,创建结果集
        vector<int> res(nums1.size(), -1);
        for(int i = 0; i < nums1.size(); ++i)
        {
            res[i] = mp_val_idx[nums1[i]];
        }

        return res;
    }
};
```

## 13.重排链表
<a href="https://leetcode-cn.com/problems/reorder-list/">Link</a>
题目介绍:
![在这里插入图片描述](https://img-blog.csdnimg.cn/6beb8059242e409e96abab18a8f79db2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

### 解法1：使用栈辅助
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        if(!head || !head->next)
        {
            return;
        }

        //1.将链表节点保存到栈中
        ListNode* curNode = head;
        stack<ListNode*> st;
        while(curNode)
        {
            st.push(curNode);
            curNode = curNode->next;
        }

        //2.将栈中的元素出栈一半，并将其链接到从链表头部开始的节点后面
        curNode = head;
        ListNode* tailNode = nullptr;       //尾节点
        int sz = st.size() / 2;
        while(sz--)
        {
            ListNode* newNode = st.top();    //新插入的节点
            st.pop();

            if(tailNode)
            {
                tailNode->next = curNode;     //让前一轮的尾节点的下一个位置指向当前节点
            }
            ListNode* cur_next = curNode->next;     //记录当前节点的下一个位置
            curNode->next = newNode;                //让当前节点的下一个位置指向新节点
            tailNode = newNode;                     //更新尾节点
            curNode = cur_next;                     //更新当前节点
        }
        //处理链表有奇数个节点的情况
        if(curNode)
        {
            tailNode->next = curNode;
            tailNode = curNode;
        }
        //让尾节点的下一个指向空
        tailNode->next = nullptr;
    }
};
```
### 解法2：反转后半部分链表+插入
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        if(head == nullptr || head->next == nullptr)
        {
            return;
        }

        //1.将链表后半部分反转
        //1.1:找到中间节点
        ListNode *fast = head, *slow = head;
        while(fast != nullptr && fast->next != nullptr)
        {
            fast = fast->next->next;
            slow = slow->next;
        } 
        //1.2:将链表的前半部分和后半部分断开联系
        fast = head;        //fast是前半部分链表的头节点
        ListNode* nextNode = slow->next;    
        slow->next = nullptr;
        slow = nextNode;     //slow是后半部分链表的头节点
        //1.3：反转后半部分
        slow = reverseList(slow);

        //2.将后半部分链表从头到尾依次链接到前半部分链表的每一个节点后面
        head = fast;
        ListNode* tailNode = nullptr;   //尾节点
        while(fast != nullptr && slow != nullptr)
        {
            ListNode* fast_next = fast->next;
            ListNode* slow_next = slow->next;

            //链接节点
            fast->next = slow;
            if(tailNode != nullptr)
            {
                tailNode->next = fast;
            }
            tailNode = slow;
            //继续向后更新
            fast = fast_next;
            slow = slow_next;
        }
        if(tailNode != nullptr)
        {
            tailNode->next = fast;
        }
    }
private:
    ListNode* reverseList(ListNode* head)
    {
        if(head == nullptr || head->next == nullptr)
        {
            return head;
        }

        ListNode* prev = nullptr;
        while(head != nullptr)
        {
            ListNode* nextNode = head->next;
            head->next = prev;
            prev = head;
            head = nextNode;
        }
        return prev;
    }
};
```

## 14.二叉搜索树迭代器
<a href="">Link</a>
题目介绍:

![在这里插入图片描述](https://img-blog.csdnimg.cn/182bb6bb688b4d6b9aa684451afebc85.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

**使用栈将二叉搜索树转换为一个有序的单链表**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class BSTIterator {
public:
    BSTIterator(TreeNode* root) 
        :_node(root)
        ,_IsFirst(true)
    {
        //将二叉搜索树按照中序遍历的顺序转换为一个单链表
        //right指向下一个节点,left指向空
        TreeNode* curNode = root;
        TreeNode* prevNode = nullptr;       //中序遍历的前一个节点
        stack<TreeNode*> st;
        TreeNode* head = nullptr;           //单链表的头节点
        while(curNode || !st.empty())
        {
            while(curNode)
            {
                st.push(curNode);
                curNode = curNode->left;
            }

            TreeNode* top = st.top();
            st.pop();
            if(!head)
            {
                head = top;
            }
            if(prevNode)
            {
                prevNode->right = top;
            }
            top->left = nullptr;
            prevNode = top;
            if(top->right)
            {
                curNode = top->right;
            }
        }
        //更新_node为链表的头节点
        _node = head;
    }
    
    int next() {
        int ret;
        //第一次访问，返回头节点的值,更新标志位
        if(_IsFirst)
        {
            ret = _node->val;
            _IsFirst = false;
        }
        else
        {
            //不是第一次访问就移动到下一个节点的位置
            _node = _node->right;
            //如果下一个节点不为空，返回节点值,否则返回-1
            if(_node)
            {
                ret = _node->val;
            }
            else
            {
                ret = -1;
            }
        }
        return ret;
    }
    
    bool hasNext() {
        if(!_node)
        {
            return false;
        }
        //第一次访问默认右边一定有节点，第一次访问默认节点指向一个比最小节点还小的位置
        if(_IsFirst)
        {
            return true;
        }
        if(_node->right)
        {
            return true;
        }
        return false;
    }
private:
    TreeNode* _node;
    bool _IsFirst;       //是不是第一次找右侧节点
};

//我的做法很粗暴，看了官方解法，没有搞明白官解关于下一个位置是否有节点的判断条件
//只能继续理解官解
//我只想说适合自己的才是最好的
/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator* obj = new BSTIterator(root);
 * int param_1 = obj->next();
 * bool param_2 = obj->hasNext();
 */
```

## 15.N叉树的后序遍历
<a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">Link</a>
题目介绍：
![在这里插入图片描述](https://img-blog.csdnimg.cn/614ecdb8a132460b834e23c125561b43.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

我可以想到使用栈这种数据结构，但是不知道怎样保证先从左到右访问孩子节点，再访问根节点的顺序，最终在官解的启发下才明白可以采用将问题分解和逆向思考问题的思路
具体见代码：

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<int> postorder(Node* root) {
        vector<int> postRes;
        if(!root)
        {
            return postRes;
        } 

        stack<Node*> st;
        st.push(root);
        while(!st.empty())
        {
            Node* top = st.top();
            st.pop();
            postRes.push_back(top->val);

            //孩子节点从左到右入栈，保证出栈时先访问右边的节点
            for(int i = 0; i < top->children.size(); ++i)
            {
                st.push(top->children[i]);
            }
        }

        //反转结果集
        reverse(postRes.begin(), postRes.end());

        return postRes;
    }
};
```

## 16.验证二叉树的前序序列化
<a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">Link</a>
题目介绍:
![在这里插入图片描述](https://img-blog.csdnimg.cn/60ca673b2b2049ec904cbc99b8aaba37.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)
### 解法1：使用栈来维护槽值的变化
```cpp
class Solution {
public:
    bool isValidSerialization(string preorder) {
        int len = preorder.size();
        //空树的前序序列是一个#
        if(len == 0)
        {
            return false;
        }

        //存储槽位，栈的后进先出的特点适合当前先处理孩子节点在处理父节点的场景
        stack<int> st;      
        st.push(1);     //初始状态槽位为1
        int idx = 0;
        while(idx < len)
        {
            //如果栈为空，但是前序序列没有遍历结束，说明前序序列不合法
            if(st.empty())
            {
                return false;
            }

            //跳过,
            if(preorder[idx] == ',')
            {
                ++idx;
            }
            //空节点会消耗一个槽值
            else if(preorder[idx] == '#')
            {
                --st.top();
                //如果栈顶元素的槽值消耗为0，让栈顶元素出栈
                if(st.top() == 0)
                {
                    st.pop();
                }
                ++idx;
            }
            //数字字符消耗一个槽值，同时会添加两个槽值
            else
            {
                //走到下一个,的位置
                while(idx < len && preorder[idx] != ',')
                {
                    ++idx;
                }
                --st.top();
                //判断栈顶的槽值是否已经消耗为0
                if(st.top() == 0)
                {
                    st.pop();
                }                    
                st.push(2);
            }
        }

        //如果前序序列遍历结束后栈为空，说明前序序列是正确的
        return st.empty();
    }
};
```

### 解法2：使用一个计数器来管理槽值

```cpp
//使用一个计数器表示所有的槽值之和
class Solution {
public:
    bool isValidSerialization(string preorder) {
        if(preorder.empty())
        {
            return false;
        }

        int len = preorder.size();
        int idx = 0;
        int cntOfSlot = 1;      //初始化槽值为1，因为即使是空节点也有一个槽值
        while(idx < len)
        {
            //前序序列没有遍历完，槽值已经消耗为0，说明序列不合法
            if(cntOfSlot == 0)
            {
                return false;
            }

            //跳过，
            if(preorder[idx] == ',')
            {
                ++idx;
            }
            //遇见#消耗一个槽值
            else if(preorder[idx] == '#')
            {
                --cntOfSlot;
                ++idx;
            }
            //数字字符
            else
            {
                while(idx < len && preorder[idx] != ',')
                {
                    ++idx;
                }
                cntOfSlot += 1;     //消耗一个槽值，增加两个槽值
            }
        }

        //判断最后的槽值是否消耗为0，消耗为0说明前序序列合法
        return cntOfSlot == 0;
    }
};
```

## 17.去除重复字母
<a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">Link</a>
题目简介：
![在这里插入图片描述](https://img-blog.csdnimg.cn/329e1c26b8cf4ba6be08576c8b4a25ed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)
### 单调栈解法
使用string维护一个从栈底到栈顶按照字母顺序递增的单调栈

```cpp
class Solution {
public:
    string removeDuplicateLetters(string s) {
        if(s.size() <= 1)
        {
            return s;
        }

        string st;                      //使用string来模拟一个栈,st的尾部就是栈顶
        vector<int> num(26, 0);         //存放每个字符的出现次数
        vector<int> visited(26, 0);     //标记每个字符是否已经放入非重复字符串中

        //1.统计每个字符的出现次数
        for(const auto& ch : s)
        {
            ++num[ch - 'a'];
        }

        //2.使用单调栈维护非重复字符串
        //此处的单调栈默认从栈底到栈顶按照字符顺序递增
        for(const auto& ch : s)
        {
            if(!visited[ch - 'a'])
            {
                //判断是否需要出栈,维护一个从栈底到栈顶按照字符顺序递增的单调栈
                while(!st.empty() && st.back() > ch)
                {
                    //如果栈顶元素对应的字符在后面的字符串中还存在，就让其出栈
                    if(num[st.back() - 'a'] > 0)        //！！！！！！[]内部忘记-'a'
                    {
                        visited[st.back() - 'a'] = 0;        //标记该元素没有在栈中出现过
                        st.pop_back();                      //出栈
                    }
                    //栈顶元素对应的字符在后面的字符串中不存在,结束循环
                    else
                    {
                        break;
                    }
                }
                visited[ch - 'a'] = 1;      //标记当前字符已经访问过
                st.push_back(ch);           //让当前字符入栈
            }
            --num[ch - 'a'];            //更新字符剩余的个数
        }

        //从栈底到栈顶的字符串就是要返回的结果
        return st;
    }
};
```

## 18.迷你语法分析器
<a href="https://leetcode-cn.com/problems/mini-parser/">Link</a>
题目简介：
![在这里插入图片描述](https://img-blog.csdnimg.cn/d0d259283f08446bac4c5dbbae86cedd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)
### 解法1：递归求解
```cpp
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Constructor initializes an empty nested list.
 *     NestedInteger();
 *
 *     // Constructor initializes a single integer.
 *     NestedInteger(int value);
 *
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Set this NestedInteger to hold a single integer.
 *     void setInteger(int value);
 *
 *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 *     void add(const NestedInteger &ni);
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */
class Solution {
public:
    NestedInteger deserialize(string s) {
        //一个纯数字字符串，直接返回构造的对象
        if(s[0] != '[')
        {
            return NestedInteger(stoi(s));
        }

        int curPos = 0;
        return dfs(s, curPos);
    }
private:
    NestedInteger dfs(const string& str, int& curPos)
    {
        NestedInteger res;
        //跳过开头的[
        if(curPos < str.size() && str[curPos] == '[')
        {
            ++curPos;
        }

        while(1)
        {
            //判断是否遍历结束，遍历结束退出循环
            if(curPos == str.size())
            {
                break;
            }

            //跳过,
            if(str[curPos] == ',')
            {
                ++curPos;
            }
            //处理数字字符
            else if(isdigit(str[curPos]) || str[curPos] == '-')
            {
                int num = 0;
                int flag = 1;
                if(str[curPos] == '-')
                {
                    flag = -1;
                    ++curPos;
                }
                while(curPos < str.size() && isdigit(str[curPos]))
                {
                    num = num * 10 + str[curPos] - '0';
                    ++curPos;
                }
                num *= flag;
                res.add(NestedInteger(num));
            }
            //遇见[,进入下一轮计算
            else if(str[curPos] == '[')
            {
                NestedInteger nextRes = dfs(str, curPos);
                res.add(nextRes);
            }
            //遇见],本轮计算结束
            else if(str[curPos] == ']')
            {
                ++curPos;
                break;
            }
        }

        return res;
    }
};
```
### 解法2：栈求解
#### 形式1：
```cpp
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Constructor initializes an empty nested list.
 *     NestedInteger();
 *
 *     // Constructor initializes a single integer.
 *     NestedInteger(int value);
 *
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Set this NestedInteger to hold a single integer.
 *     void setInteger(int value);
 *
 *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 *     void add(const NestedInteger &ni);
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */
class Solution {
public:
    NestedInteger deserialize(string s) {
        vector<NestedInteger> arr;	//使用vector模拟一个栈，尾部就是栈顶
        string str;             //用于扫描的缓冲区
        for(const auto& ch : s)
        {
            //[标识着一个新的NestedInteger对象构造的开始
            if(ch == '[')
            {
                arr.push_back(NestedInteger());
            }
            //,标识着一个整型数字的扫描结束
            else if(ch == ',')
            {
                //stoi不能对空字符串进行转换
                //预防这种格式的数据:"[123,456,[788,799,833],[[]],10,[]]"
                if(!str.empty())
                {
                    //将这个新的NestedInteger对象插入栈顶元素对银行的对象中
                    arr.back().add(NestedInteger(stoi(str)));
                    //清空缓冲区
                    str.clear();
                }
            }
            //遇见]标识一个NestedInteget对象扫描结束
            else if(ch == ']')
            {
                //stoi不能对空字符串进行转换
                //预防这种格式的数据："[123,[456,[789]]]"
                //因为在处理倒数第2个]的时候str就是一个空字符串
                if(!str.empty())
                {
                    arr.back().add(NestedInteger(stoi(str)));
                    str.clear();
                }
                //栈中不只一个元素，将栈顶元素出栈，并插入新的栈顶元素的尾部
                if(arr.size() > 1)
                {
                    NestedInteger rear = arr.back();
                    arr.pop_back();
                    arr.back().add(rear);
                }
            }
            //遇见数字字符和'-'将其插入缓冲区,'-'不需要单独处理，因为stoi可以处理-
            else
            {
                str.push_back(ch);
            }
        }

        //处理没有以]结束的情况
        if(!str.empty())
        {
            arr.push_back(NestedInteger(stoi(str)));
        }

        return arr.back();
    }
};
```

#### 形式2：

```cpp
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Constructor initializes an empty nested list.
 *     NestedInteger();
 *
 *     // Constructor initializes a single integer.
 *     NestedInteger(int value);
 *
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Set this NestedInteger to hold a single integer.
 *     void setInteger(int value);
 *
 *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 *     void add(const NestedInteger &ni);
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */
class Solution {
public:
    NestedInteger deserialize(string s) {
        //处理空字符串
        if(s.empty())
        {
            return NestedInteger();
        }

        if(s[0] != '[')
        {
            return NestedInteger(stoi(s));
        }

        stack<NestedInteger> st;
        string curStr;          //扫描过的数字字符
        for(const auto& ch : s)
        {
            //[标识着新一轮计算的开始，向栈中入栈一个空的对象
            if(ch == '[')
            {
                st.push(NestedInteger());
            }
            //,标识着一个数字扫描结束
            else if(ch == ',')
            {
                //stoi不能对空的string对象进行转换，形式如：],这样的字符串会产生一个空的string对象
                if(!curStr.empty())
                {
                    st.top().add(NestedInteger(stoi(curStr)));
                    curStr.clear();
                }
            }
            //]标识着一个对象构造结束
            else if(ch == ']')
            {
                //可能会有连续的],这个时候在遇见第二个]时的curStr是空的，而stoi不能对于空的string进行转换
                if(!curStr.empty())
                {
                    st.top().add(NestedInteger(stoi(curStr)));
                    curStr.clear();
                }
                //这是一个嵌套的整体,所以保持栈中只有一个元素
                if(st.size() > 1)
                {
                    NestedInteger topVal = st.top();
                    st.pop();

                    st.top().add(topVal);
                }
            }
            //数字字符或者'-'将其插入字符串中
            else if(isdigit(ch) || ch == '-')
            {
                curStr.push_back(ch);
            }
        }

        //处理没有以]结束的字符串
        if(!curStr.empty())
        {
            st.push(NestedInteger(stoi(curStr)));
        }

        return st.top();
    }
};
```

## 19.两数相加II
<a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">Link</a>
题目介绍：
![在这里插入图片描述](https://img-blog.csdnimg.cn/15c39a213c0a478799adfc16be70d4ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        //1.将两个链表节点入栈
        stack<ListNode*> st1;
        stack<ListNode*> st2;
        ListNode *node1 = l1, *node2 = l2;
        while(node1)
        {
            st1.push(node1);
            node1 = node1->next;
        }
        while(node2)
        {
            st2.push(node2);
            node2 = node2->next;
        }

        ListNode* dummyHead = new ListNode(-1);     //一个哑巴节点
        dummyHead->next = nullptr;

        //2.借助栈辅助进行累加
        int carry = 0;      //进位
        //两个链表从尾部到头部进行累加
        while(!st1.empty() || !st2.empty())
        {
            int num1 = 0; 
            int num2 = 0;

            if(!st1.empty())
            {
                num1 = st1.top()->val;
                st1.pop();
            }
            if(!st2.empty())
            {
                num2 = st2.top()->val;
                st2.pop();
            }
            
            int sum = num1 + num2 + carry;
            carry = sum / 10;   //重新计算进位      

            //将新节点头插到链表中
            ListNode* newNode = new ListNode(sum % 10);
            ListNode* head_next = dummyHead->next;
            dummyHead->next = newNode;
            newNode->next = head_next;
        }
        //处理剩余的进位
        if(carry > 0)
        {
            //将新节点头插到链表中
            ListNode* newNode = new ListNode(carry);
            ListNode* head_next = dummyHead->next;
            dummyHead->next = newNode;
            newNode->next = head_next;
        }
        
        return dummyHead->next;
    }
};
```

## 20.下一个更大元素II
<a href="https://leetcode-cn.com/problems/next-greater-element-ii/submissions/">Link</a>
题目简介：
![在这里插入图片描述](https://img-blog.csdnimg.cn/acc5b1a901434a55bd7f0a709fa1e525.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

### 解法1：维护一个从栈底到栈顶单调递增的单调栈
```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        if(nums.empty())
        {
            return vector<int>();
        }

        int len = nums.size();
        vector<int> res(len, -1);

        stack<int> st;  //一个从栈底到栈顶递增的单调栈
        
        //1.初始化单调栈
        //因为这是一个循环数组，所以需要先将每个元素后面的情况考虑进去
        for(int i = len - 1; i >= 0; --i)
        {
            while(!st.empty() && nums[i] >= nums[st.top()])
            {
                st.pop();
            }
            st.push(i);
        }

        //2.从数组的尾部到头部进行遍历，查找右边的元素
        for(int i = len - 1; i >= 0; --i)
        {
            while(!st.empty() && nums[i] >= nums[st.top()])
            {
                st.pop();
            }
            if(!st.empty())
            {
                res[i] = nums[st.top()];
            }
            st.push(i);
        }

        return res;
    }
};
```

### 解法2：维护一个从栈底到栈顶单调递减的单调栈

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        if(nums.empty())
        {
            return vector<int>();
        }

        stack<int> st;          //一个从栈底到栈顶递减的单调栈
        int len = nums.size();
        vector<int> res(len, -1);
        for(int i = 0; i < 2 * len - 1; ++i)
        {
            while(!st.empty() && nums[i % len] > nums[st.top()])
            {
                res[st.top()] = nums[i % len];      //当前元素比栈顶元素大,当前元素的栈顶元素右边遇到的第一个比它大的值
                st.pop();
            }
            st.push(i % len);
        }

        return res;
    }
};
```

## 21.下一个更大元素III
<a href="https://leetcode-cn.com/problems/next-greater-element-iii/">Link</a>
题目简介：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2e1bc65ef9cb4864ac8a6fce9f3518e6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

将整数转换为字符串进行处理：
```cpp
//将整形转换为字符串进行处理
class Solution {
public:
    int nextGreaterElement(int n) {
        string str = to_string(n);
        if(str.size() <= 1)
        {
            return -1;
        }

        int len = str.size();
        int last = len - 2;
        
        //1.从后往前找第一个小于后一项的位置
        while(last >= 0)
        {
            if(str[last] < str[last + 1])
            {
                break;
            }
            --last;
        }
        //如果元素呈降序排列，返回-1
        if(last == -1)
        {
            return -1;
        }

        //2.从后往前找第一个大于last位置处元素的位置
        int pos = len - 1;
        while(pos > last)
        {
            if(str[pos] > str[last])
            {
                break;
            }
            --pos;
        }
        //last位置后面没有元素的值大于大于它，也就是说找不到更大值
        if(pos == last)
        {
            return -1;
        }

        //3.交换两个位置处的值
        swap(str[pos], str[last]);

        //4.反转last后面的元素，让降序变为升序，保证成为最小的大于原来值的数
        reverse(str.begin() + last + 1, str.end());

        long res = stol(str);
        //判断是否越界
        if(res > INT_MAX)
        {
            return -1;
        }
        return res;
    }
};
```

## 22.文件的最长绝对路径
<a href="https://leetcode-cn.com/problems/longest-absolute-file-path/">Link</a>

题目介绍:
![在这里插入图片描述](https://img-blog.csdnimg.cn/b326af465e344444bdd4da0a868d1ee1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/c16217d1b75f4e4fabd0d4d54f5bd3c2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

解题思路：
将问题逐步分解，
先将目录根据'\n'进行切割；
在遍历切割结果的过程中使用栈来维护；

代码：

```cpp
//节点类，内部封装了两个成员，一个是当前路径对应的层级，一个是当前路径的长度
struct Node
{
	int _level;         //层级
	int _routeLen;      //当前路径长度

	Node(int level, int routeLen)
		:_level(level)
		, _routeLen(routeLen)
	{}
};

class Solution {
public:
	int lengthLongestPath(string input) {
		//1.根据\n进行分割
		vector<string> splitsRes = SplitByEnter(input);

		//2.遍历数组的过程中压栈出栈
		int len = splitsRes.size();
		size_t maxRouteLen = 0;
		stack<Node*> st;
		int idx = 0;
		while (idx < len)
		{
			//计算\t的个数,\t的个数可以标识层级
			int TableSz = countTable(splitsRes[idx]);

			if (st.empty())
			{
				//栈为空，当前路径为文件路径，更新结果集
				if (splitsRes[idx].find('.') != string::npos)
				{
					maxRouteLen = max(maxRouteLen, splitsRes[idx].size());
				}
				//栈为空，但是当前路径不是文件路径，说明当前目录是根目录，将当前路径构造为一个节点入栈
				else
				{
					Node* newNode = new Node(0, splitsRes[idx].size());
					st.push(newNode);
				}
				//走到下一个路径的位置
				++idx;
			}
			//栈不为空的判断内部逻辑需要仔细, 耐心, 认真地检查!!!!!!!!!!!
			else
			{
				//栈不为空，当前路径是文件路径
				if (splitsRes[idx].find('.') != string::npos)
				{
					//栈顶目录是当前路径的上级目录，根据上级目录计算当前路径长度
					if (st.top()->_level + 1 == TableSz)
					{
						//当前路径的长度等于上级目录的长度+当前路径中有效长度 + 1('\'的长度)
						maxRouteLen = max(maxRouteLen, st.top()->_routeLen + splitsRes[idx].size() - TableSz + 1);
						//走到下一个目录处
						++idx;
					}
					//栈顶元素不是当前路径的上级目录,让栈顶元素出栈
					else
					{
						st.pop();
					}
				}
				//栈不为空，但是当前路径不是文件路径，将当前路径构造为一个节点入栈
				else
				{
					//满足上下级关系,构建一个节点并入栈
					if (st.top()->_level + 1 == TableSz)
					{
						Node* newNode = new Node(TableSz, st.top()->_routeLen + splitsRes[idx].size() - TableSz + 1);
						st.push(newNode);
						//走到下一个目录的位置
						++idx;
					}
					//不满足上下文关系，让栈顶元素出栈
					else
					{
						st.pop();
					}
				}
			}
		}

		return maxRouteLen;
	}
private:
	//根据\n进行分割
    //这里有一个问题，将函数的返回值设置为引用，将函数内部的res设置为静态变量，在力扣中相同的测试用例通过，但是在最后的提交中相同的测试用例却会失败
	vector<string> SplitByEnter(const string& str)
	{
		vector<string> res;
		string curStr;
		for (auto& e : str)
		{
			if (e == '\n')
			{
				res.push_back(curStr);
				curStr.clear();
			}
			else
			{
				curStr.push_back(e);
			}
		}
		if (!curStr.empty())
		{
			res.push_back(curStr);
		}

		return res;
	}

	//统计\t的个数
	int countTable(const string& str)
	{
		int cnt = 0;
		int len = str.size(), idx = 0;
		while (idx < len)
		{
			if (str[idx] == '\t')
			{
				++cnt;
			}
			++idx;
		}
		return cnt;
	}
};
```


## 23.买卖股票的最佳时机
<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/submissions/">Link</a>
题目介绍:
![在这里插入图片描述](https://img-blog.csdnimg.cn/dfae2c7a84664996b61e090b60e44d6c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3hweGF0dTUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

### 解法1：维护一个最小股价
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minPrice = INT_MAX;
        int ret = 0;
        
        //维护一个最小价格，遍历数组的同时更新最小价格
        for(const auto& price : prices)
        {
            //当前股票的价格小于最小价格，更新最小价格
            if(price < minPrice)
            {
                minPrice = price;
            }
            //当前股票价格大于等于最小价格，更新最大利润
            else
            {
                ret = max(ret, price - minPrice);
            }
        }

        return ret;
    }
};
```

### 解法2：单调栈+哨兵节点
**最初看见这道题目的时候我想到了使用单调栈，但是我的思路不够完善，就中间废弃了单调栈的思路，对于栈的使用很不灵活，栈只是一种数据的存放形式，符合后进先出的特点，可以使用多种容器来实现栈，不应该局限于只是用stl中的stack，vector就很适合当前的应用场景**
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        //股票的价格都是大于0的值，插入-1作为哨兵
        prices.push_back(-1);       
        //使用vector维护一个从栈底到栈顶递增的单调栈，vector的尾部就是栈顶
        vector<int> st;             
        int maxVal = 0;

        //-1作为哨兵节点，比任何一个节点都小，借助哨兵节点可以获取最后一组数据的结果
        for(int i = 0; i < prices.size(); ++i)
        {
            //当有新元素比栈顶元素小的时候，让栈顶元素出栈，维护一个从栈底到栈顶单调递增的单调栈,同时更新获得的最大利润
            while(!st.empty() && st.back() > prices[i])
            {
                maxVal = max(maxVal, st.back() - st.front());
                st.pop_back();
            }
            st.push_back(prices[i]);
        }        

        return maxVal;
    }
};
```
